var $8C1kk$path = require("path");
var $8C1kk$stream = require("stream");
var $8C1kk$parcelsourcemap = require("@parcel/source-map");
var $8C1kk$parcellogger = require("@parcel/logger");
var $8C1kk$crypto = require("crypto");
var $8C1kk$os = require("os");
var $8C1kk$util = require("util");
var $8C1kk$fs = require("fs");
var $8C1kk$events = require("events");
var $8C1kk$parcelcodeframe = require("@parcel/codeframe");
var $8C1kk$parcelmarkdownansi = require("@parcel/markdown-ansi");
var $8C1kk$chalk = require("chalk");
var $8C1kk$tty = require("tty");
var $8C1kk$assert = require("assert");
var $8C1kk$parceldiagnostic = require("@parcel/diagnostic");
var $8C1kk$url = require("url");
var $8C1kk$child_process = require("child_process");
var $8C1kk$buffer = require("buffer");
var $8C1kk$parcelhash = require("@parcel/hash");
var $8C1kk$http = require("http");
var $8C1kk$https = require("https");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire0b48"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire0b48"] = parcelRequire;
}
parcelRequire.register("iGlOy", function(module, exports) {
/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */ module.exports = {
    // default options
    options: {
        usePureJavaScript: false
    }
};

});

parcelRequire.register("ai0Z9", function(module, exports) {
/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */ 
var $iGlOy = parcelRequire("iGlOy");
module.exports = $iGlOy.md = $iGlOy.md || {};
$iGlOy.md.algorithms = $iGlOy.md.algorithms || {};

});

parcelRequire.register("4997P", function(module, exports) {
"use strict";


var $2zM8v = parcelRequire("2zM8v");

var $lKEF0 = parcelRequire("lKEF0");

var $5MQDC = parcelRequire("5MQDC");

var $7XmS6 = parcelRequire("7XmS6");
const $304f14c7e435813f$var$isObject = (val)=>val && typeof val === "object" && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */ const $304f14c7e435813f$var$picomatch = (glob, options, returnState = false)=>{
    if (Array.isArray(glob)) {
        const fns = glob.map((input)=>$304f14c7e435813f$var$picomatch(input, options, returnState));
        const arrayMatcher = (str)=>{
            for (const isMatch of fns){
                const state = isMatch(str);
                if (state) return state;
            }
            return false;
        };
        return arrayMatcher;
    }
    const isState = $304f14c7e435813f$var$isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) throw new TypeError("Expected pattern to be a non-empty string");
    const opts = options || {};
    const posix = $5MQDC.isWindows(options);
    const regex = isState ? $304f14c7e435813f$var$picomatch.compileRe(glob, options) : $304f14c7e435813f$var$picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = ()=>false;
    if (opts.ignore) {
        const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null
        };
        isIgnored = $304f14c7e435813f$var$picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false)=>{
        const { isMatch: isMatch , match: match , output: output  } = $304f14c7e435813f$var$picomatch.test(input, regex, options, {
            glob: glob,
            posix: posix
        });
        const result = {
            glob: glob,
            state: state,
            regex: regex,
            posix: posix,
            input: input,
            output: output,
            match: match,
            isMatch: isMatch
        };
        if (typeof opts.onResult === "function") opts.onResult(result);
        if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") opts.onIgnore(result);
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") opts.onMatch(result);
        return returnObject ? result : true;
    };
    if (returnState) matcher.state = state;
    return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */ $304f14c7e435813f$var$picomatch.test = (input, regex, options, { glob: glob , posix: posix  } = {})=>{
    if (typeof input !== "string") throw new TypeError("Expected input to be a string");
    if (input === "") return {
        isMatch: false,
        output: ""
    };
    const opts = options || {};
    const format = opts.format || (posix ? $5MQDC.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
    }
    if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) match = $304f14c7e435813f$var$picomatch.matchBase(input, regex, options, posix);
        else match = regex.exec(output);
    }
    return {
        isMatch: Boolean(match),
        match: match,
        output: output
    };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */ $304f14c7e435813f$var$picomatch.matchBase = (input, glob, options, posix = $5MQDC.isWindows(options))=>{
    const regex = glob instanceof RegExp ? glob : $304f14c7e435813f$var$picomatch.makeRe(glob, options);
    return regex.test($8C1kk$path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ $304f14c7e435813f$var$picomatch.isMatch = (str, patterns, options)=>$304f14c7e435813f$var$picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */ $304f14c7e435813f$var$picomatch.parse = (pattern, options)=>{
    if (Array.isArray(pattern)) return pattern.map((p)=>$304f14c7e435813f$var$picomatch.parse(p, options));
    return $lKEF0(pattern, {
        ...options,
        fastpaths: false
    });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ $304f14c7e435813f$var$picomatch.scan = (input, options)=>$2zM8v(input, options);
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */ $304f14c7e435813f$var$picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
    if (returnOutput === true) return state.output;
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) source = `^(?!${source}).*$`;
    const regex = $304f14c7e435813f$var$picomatch.toRegex(source, options);
    if (returnState === true) regex.state = state;
    return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ $304f14c7e435813f$var$picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
    if (!input || typeof input !== "string") throw new TypeError("Expected a non-empty string");
    let parsed = {
        negated: false,
        fastpaths: true
    };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) parsed.output = $lKEF0.fastpaths(input, options);
    if (!parsed.output) parsed = $lKEF0(input, options);
    return $304f14c7e435813f$var$picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */ $304f14c7e435813f$var$picomatch.toRegex = (source, options)=>{
    try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
    }
};
/**
 * Picomatch constants.
 * @return {Object}
 */ $304f14c7e435813f$var$picomatch.constants = $7XmS6;
/**
 * Expose "picomatch"
 */ module.exports = $304f14c7e435813f$var$picomatch;

});
parcelRequire.register("2zM8v", function(module, exports) {
"use strict";

var $5MQDC = parcelRequire("5MQDC");

var $7XmS6 = parcelRequire("7XmS6");
var $1e0430853cfb927a$require$CHAR_ASTERISK = $7XmS6.CHAR_ASTERISK;
var $1e0430853cfb927a$require$CHAR_AT = $7XmS6.CHAR_AT;
var $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH = $7XmS6.CHAR_BACKWARD_SLASH;
var $1e0430853cfb927a$require$CHAR_COMMA = $7XmS6.CHAR_COMMA;
var $1e0430853cfb927a$require$CHAR_DOT = $7XmS6.CHAR_DOT;
var $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK = $7XmS6.CHAR_EXCLAMATION_MARK;
var $1e0430853cfb927a$require$CHAR_FORWARD_SLASH = $7XmS6.CHAR_FORWARD_SLASH;
var $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE = $7XmS6.CHAR_LEFT_CURLY_BRACE;
var $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES = $7XmS6.CHAR_LEFT_PARENTHESES;
var $1e0430853cfb927a$require$CHAR_LEFT_SQUARE_BRACKET = $7XmS6.CHAR_LEFT_SQUARE_BRACKET;
var $1e0430853cfb927a$require$CHAR_PLUS = $7XmS6.CHAR_PLUS;
var $1e0430853cfb927a$require$CHAR_QUESTION_MARK = $7XmS6.CHAR_QUESTION_MARK;
var $1e0430853cfb927a$require$CHAR_RIGHT_CURLY_BRACE = $7XmS6.CHAR_RIGHT_CURLY_BRACE;
var $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES = $7XmS6.CHAR_RIGHT_PARENTHESES;
var $1e0430853cfb927a$require$CHAR_RIGHT_SQUARE_BRACKET = $7XmS6.CHAR_RIGHT_SQUARE_BRACKET;
const $1e0430853cfb927a$var$isPathSeparator = (code)=>{
    return code === $1e0430853cfb927a$require$CHAR_FORWARD_SLASH || code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH;
};
const $1e0430853cfb927a$var$depth = (token)=>{
    if (token.isPrefix !== true) token.depth = token.isGlobstar ? Infinity : 1;
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */ const $1e0430853cfb927a$var$scan = (input, options)=>{
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
        value: "",
        depth: 0,
        isGlob: false
    };
    const eos = ()=>index >= length;
    const peek = ()=>str.charCodeAt(index + 1);
    const advance = ()=>{
        prev = code;
        return str.charCodeAt(++index);
    };
    while(index < length){
        code = advance();
        let next;
        if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) braceEscaped = true;
            continue;
        }
        if (braceEscaped === true || code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while(eos() !== true && (code = advance())){
                if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === $1e0430853cfb927a$require$CHAR_DOT && (code = advance()) === $1e0430853cfb927a$require$CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (braceEscaped !== true && code === $1e0430853cfb927a$require$CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (code === $1e0430853cfb927a$require$CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = {
                value: "",
                depth: 0,
                isGlob: false
            };
            if (finished === true) continue;
            if (prev === $1e0430853cfb927a$require$CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            const isExtglobChar = code === $1e0430853cfb927a$require$CHAR_PLUS || code === $1e0430853cfb927a$require$CHAR_AT || code === $1e0430853cfb927a$require$CHAR_ASTERISK || code === $1e0430853cfb927a$require$CHAR_QUESTION_MARK || code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK && index === start) negatedExtglob = true;
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === $1e0430853cfb927a$require$CHAR_ASTERISK) {
            if (prev === $1e0430853cfb927a$require$CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_LEFT_SQUARE_BRACKET) {
            while(eos() !== true && (next = advance())){
                if (next === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === $1e0430853cfb927a$require$CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (opts.nonegate !== true && code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while(eos() !== true && (code = advance())){
                    if (code === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    } else if (isGlob === true) {
        base = "";
        glob = str;
    } else base = str;
    if (base && base !== "" && base !== "/" && base !== str) {
        if ($1e0430853cfb927a$var$isPathSeparator(base.charCodeAt(base.length - 1))) base = base.slice(0, -1);
    }
    if (opts.unescape === true) {
        if (glob) glob = $5MQDC.removeBackslashes(glob);
        if (base && backslashes === true) base = $5MQDC.removeBackslashes(base);
    }
    const state = {
        prefix: prefix,
        input: input,
        start: start,
        base: base,
        glob: glob,
        isBrace: isBrace,
        isBracket: isBracket,
        isGlob: isGlob,
        isExtglob: isExtglob,
        isGlobstar: isGlobstar,
        negated: negated,
        negatedExtglob: negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!$1e0430853cfb927a$var$isPathSeparator(code)) tokens.push(token);
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for(let idx = 0; idx < slashes.length; idx++){
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                } else tokens[idx].value = value;
                $1e0430853cfb927a$var$depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") parts.push(value);
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            const value1 = input.slice(prevIndex + 1);
            parts.push(value1);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value1;
                $1e0430853cfb927a$var$depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = $1e0430853cfb927a$var$scan;

});
parcelRequire.register("5MQDC", function(module, exports) {

$parcel$export(module.exports, "isObject", () => $436a44408af843d4$export$a6cdc56e425d0d0a, (v) => $436a44408af843d4$export$a6cdc56e425d0d0a = v);
$parcel$export(module.exports, "hasRegexChars", () => $436a44408af843d4$export$6540a013a39bb50d, (v) => $436a44408af843d4$export$6540a013a39bb50d = v);
$parcel$export(module.exports, "escapeRegex", () => $436a44408af843d4$export$104ed90cc1a13451, (v) => $436a44408af843d4$export$104ed90cc1a13451 = v);
$parcel$export(module.exports, "toPosixSlashes", () => $436a44408af843d4$export$e610e037975797ee, (v) => $436a44408af843d4$export$e610e037975797ee = v);
$parcel$export(module.exports, "removeBackslashes", () => $436a44408af843d4$export$f403de0a7ba7a743, (v) => $436a44408af843d4$export$f403de0a7ba7a743 = v);
$parcel$export(module.exports, "supportsLookbehinds", () => $436a44408af843d4$export$bcf709e5e3483cdb, (v) => $436a44408af843d4$export$bcf709e5e3483cdb = v);
$parcel$export(module.exports, "isWindows", () => $436a44408af843d4$export$f993c945890e93ba, (v) => $436a44408af843d4$export$f993c945890e93ba = v);
$parcel$export(module.exports, "escapeLast", () => $436a44408af843d4$export$13d0f4185f159c8, (v) => $436a44408af843d4$export$13d0f4185f159c8 = v);
$parcel$export(module.exports, "removePrefix", () => $436a44408af843d4$export$f2888183a34644d4, (v) => $436a44408af843d4$export$f2888183a34644d4 = v);
$parcel$export(module.exports, "wrapOutput", () => $436a44408af843d4$export$25bddda26836484b, (v) => $436a44408af843d4$export$25bddda26836484b = v);
var $436a44408af843d4$export$a6cdc56e425d0d0a;
var $436a44408af843d4$export$6540a013a39bb50d;
var $436a44408af843d4$export$a92319f7ab133839;
var $436a44408af843d4$export$104ed90cc1a13451;
var $436a44408af843d4$export$e610e037975797ee;
var $436a44408af843d4$export$f403de0a7ba7a743;
var $436a44408af843d4$export$bcf709e5e3483cdb;
var $436a44408af843d4$export$f993c945890e93ba;
var $436a44408af843d4$export$13d0f4185f159c8;
var $436a44408af843d4$export$f2888183a34644d4;
var $436a44408af843d4$export$25bddda26836484b;
"use strict";

const $436a44408af843d4$var$win32 = process.platform === "win32";

var $7XmS6 = parcelRequire("7XmS6");
var $436a44408af843d4$require$REGEX_BACKSLASH = $7XmS6.REGEX_BACKSLASH;
var $436a44408af843d4$require$REGEX_REMOVE_BACKSLASH = $7XmS6.REGEX_REMOVE_BACKSLASH;
var $436a44408af843d4$require$REGEX_SPECIAL_CHARS = $7XmS6.REGEX_SPECIAL_CHARS;
var $436a44408af843d4$require$REGEX_SPECIAL_CHARS_GLOBAL = $7XmS6.REGEX_SPECIAL_CHARS_GLOBAL;
$436a44408af843d4$export$a6cdc56e425d0d0a = (val)=>val !== null && typeof val === "object" && !Array.isArray(val);
$436a44408af843d4$export$6540a013a39bb50d = (str)=>$436a44408af843d4$require$REGEX_SPECIAL_CHARS.test(str);
$436a44408af843d4$export$a92319f7ab133839 = (str)=>str.length === 1 && $436a44408af843d4$export$6540a013a39bb50d(str);
$436a44408af843d4$export$104ed90cc1a13451 = (str)=>str.replace($436a44408af843d4$require$REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
$436a44408af843d4$export$e610e037975797ee = (str)=>str.replace($436a44408af843d4$require$REGEX_BACKSLASH, "/");
$436a44408af843d4$export$f403de0a7ba7a743 = (str)=>{
    return str.replace($436a44408af843d4$require$REGEX_REMOVE_BACKSLASH, (match)=>{
        return match === "\\" ? "" : match;
    });
};
$436a44408af843d4$export$bcf709e5e3483cdb = ()=>{
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) return true;
    return false;
};
$436a44408af843d4$export$f993c945890e93ba = (options)=>{
    if (options && typeof options.windows === "boolean") return options.windows;
    return $436a44408af843d4$var$win32 === true || $8C1kk$path.sep === "\\";
};
$436a44408af843d4$export$13d0f4185f159c8 = (input, char, lastIdx)=>{
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === "\\") return $436a44408af843d4$export$13d0f4185f159c8(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};
$436a44408af843d4$export$f2888183a34644d4 = (input, state = {})=>{
    let output = input;
    if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
    }
    return output;
};
$436a44408af843d4$export$25bddda26836484b = (input, state = {}, options = {})=>{
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) output = `(?:^(?!${output}).*$)`;
    return output;
};

});
parcelRequire.register("7XmS6", function(module, exports) {
"use strict";

const $017eb4c9ec326d4f$var$WIN_SLASH = "\\\\/";
const $017eb4c9ec326d4f$var$WIN_NO_SLASH = `[^${$017eb4c9ec326d4f$var$WIN_SLASH}]`;
/**
 * Posix glob regex
 */ const $017eb4c9ec326d4f$var$DOT_LITERAL = "\\.";
const $017eb4c9ec326d4f$var$PLUS_LITERAL = "\\+";
const $017eb4c9ec326d4f$var$QMARK_LITERAL = "\\?";
const $017eb4c9ec326d4f$var$SLASH_LITERAL = "\\/";
const $017eb4c9ec326d4f$var$ONE_CHAR = "(?=.)";
const $017eb4c9ec326d4f$var$QMARK = "[^/]";
const $017eb4c9ec326d4f$var$END_ANCHOR = `(?:${$017eb4c9ec326d4f$var$SLASH_LITERAL}|$)`;
const $017eb4c9ec326d4f$var$START_ANCHOR = `(?:^|${$017eb4c9ec326d4f$var$SLASH_LITERAL})`;
const $017eb4c9ec326d4f$var$DOTS_SLASH = `${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}${$017eb4c9ec326d4f$var$END_ANCHOR}`;
const $017eb4c9ec326d4f$var$NO_DOT = `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL})`;
const $017eb4c9ec326d4f$var$NO_DOTS = `(?!${$017eb4c9ec326d4f$var$START_ANCHOR}${$017eb4c9ec326d4f$var$DOTS_SLASH})`;
const $017eb4c9ec326d4f$var$NO_DOT_SLASH = `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{0,1}${$017eb4c9ec326d4f$var$END_ANCHOR})`;
const $017eb4c9ec326d4f$var$NO_DOTS_SLASH = `(?!${$017eb4c9ec326d4f$var$DOTS_SLASH})`;
const $017eb4c9ec326d4f$var$QMARK_NO_DOT = `[^.${$017eb4c9ec326d4f$var$SLASH_LITERAL}]`;
const $017eb4c9ec326d4f$var$STAR = `${$017eb4c9ec326d4f$var$QMARK}*?`;
const $017eb4c9ec326d4f$var$POSIX_CHARS = {
    DOT_LITERAL: $017eb4c9ec326d4f$var$DOT_LITERAL,
    PLUS_LITERAL: $017eb4c9ec326d4f$var$PLUS_LITERAL,
    QMARK_LITERAL: $017eb4c9ec326d4f$var$QMARK_LITERAL,
    SLASH_LITERAL: $017eb4c9ec326d4f$var$SLASH_LITERAL,
    ONE_CHAR: $017eb4c9ec326d4f$var$ONE_CHAR,
    QMARK: $017eb4c9ec326d4f$var$QMARK,
    END_ANCHOR: $017eb4c9ec326d4f$var$END_ANCHOR,
    DOTS_SLASH: $017eb4c9ec326d4f$var$DOTS_SLASH,
    NO_DOT: $017eb4c9ec326d4f$var$NO_DOT,
    NO_DOTS: $017eb4c9ec326d4f$var$NO_DOTS,
    NO_DOT_SLASH: $017eb4c9ec326d4f$var$NO_DOT_SLASH,
    NO_DOTS_SLASH: $017eb4c9ec326d4f$var$NO_DOTS_SLASH,
    QMARK_NO_DOT: $017eb4c9ec326d4f$var$QMARK_NO_DOT,
    STAR: $017eb4c9ec326d4f$var$STAR,
    START_ANCHOR: $017eb4c9ec326d4f$var$START_ANCHOR
};
/**
 * Windows glob regex
 */ const $017eb4c9ec326d4f$var$WINDOWS_CHARS = {
    ...$017eb4c9ec326d4f$var$POSIX_CHARS,
    SLASH_LITERAL: `[${$017eb4c9ec326d4f$var$WIN_SLASH}]`,
    QMARK: $017eb4c9ec326d4f$var$WIN_NO_SLASH,
    STAR: `${$017eb4c9ec326d4f$var$WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$)`,
    NO_DOT: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${$017eb4c9ec326d4f$var$WIN_SLASH}])${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{0,1}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${$017eb4c9ec326d4f$var$WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${$017eb4c9ec326d4f$var$WIN_SLASH}])`,
    END_ANCHOR: `(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$)`
};
/**
 * POSIX Bracket Regex
 */ const $017eb4c9ec326d4f$var$POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
};
module.exports = {
    MAX_LENGTH: 65536,
    POSIX_REGEX_SOURCE: $017eb4c9ec326d4f$var$POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */ CHAR_9: 57,
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */ CHAR_LOWERCASE_A: 97,
    /* a */ CHAR_UPPERCASE_Z: 90,
    /* Z */ CHAR_LOWERCASE_Z: 122,
    /* z */ CHAR_LEFT_PARENTHESES: 40,
    /* ( */ CHAR_RIGHT_PARENTHESES: 41,
    /* ) */ CHAR_ASTERISK: 42,
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */ CHAR_AT: 64,
    /* @ */ CHAR_BACKWARD_SLASH: 92,
    /* \ */ CHAR_CARRIAGE_RETURN: 13,
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */ CHAR_COLON: 58,
    /* : */ CHAR_COMMA: 44,
    /* , */ CHAR_DOT: 46,
    /* . */ CHAR_DOUBLE_QUOTE: 34,
    /* " */ CHAR_EQUAL: 61,
    /* = */ CHAR_EXCLAMATION_MARK: 33,
    /* ! */ CHAR_FORM_FEED: 12,
    /* \f */ CHAR_FORWARD_SLASH: 47,
    /* / */ CHAR_GRAVE_ACCENT: 96,
    /* ` */ CHAR_HASH: 35,
    /* # */ CHAR_HYPHEN_MINUS: 45,
    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */ CHAR_LEFT_CURLY_BRACE: 123,
    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */ CHAR_LINE_FEED: 10,
    /* \n */ CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */ CHAR_PERCENT: 37,
    /* % */ CHAR_PLUS: 43,
    /* + */ CHAR_QUESTION_MARK: 63,
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */ CHAR_SEMICOLON: 59,
    /* ; */ CHAR_SINGLE_QUOTE: 39,
    /* ' */ CHAR_SPACE: 32,
    /*   */ CHAR_TAB: 9,
    /* \t */ CHAR_UNDERSCORE: 95,
    /* _ */ CHAR_VERTICAL_LINE: 124,
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */ SEP: $8C1kk$path.sep,
    /**
   * Create EXTGLOB_CHARS
   */ extglobChars (chars) {
        return {
            "!": {
                type: "negate",
                open: "(?:(?!(?:",
                close: `))${chars.STAR})`
            },
            "?": {
                type: "qmark",
                open: "(?:",
                close: ")?"
            },
            "+": {
                type: "plus",
                open: "(?:",
                close: ")+"
            },
            "*": {
                type: "star",
                open: "(?:",
                close: ")*"
            },
            "@": {
                type: "at",
                open: "(?:",
                close: ")"
            }
        };
    },
    /**
   * Create GLOB_CHARS
   */ globChars (win32) {
        return win32 === true ? $017eb4c9ec326d4f$var$WINDOWS_CHARS : $017eb4c9ec326d4f$var$POSIX_CHARS;
    }
};

});



parcelRequire.register("lKEF0", function(module, exports) {
"use strict";

var $7XmS6 = parcelRequire("7XmS6");

var $5MQDC = parcelRequire("5MQDC");
/**
 * Constants
 */ const { MAX_LENGTH: $fd5d6f248e5b4a63$var$MAX_LENGTH , POSIX_REGEX_SOURCE: $fd5d6f248e5b4a63$var$POSIX_REGEX_SOURCE , REGEX_NON_SPECIAL_CHARS: $fd5d6f248e5b4a63$var$REGEX_NON_SPECIAL_CHARS , REGEX_SPECIAL_CHARS_BACKREF: $fd5d6f248e5b4a63$var$REGEX_SPECIAL_CHARS_BACKREF , REPLACEMENTS: $fd5d6f248e5b4a63$var$REPLACEMENTS  } = $7XmS6;
/**
 * Helpers
 */ const $fd5d6f248e5b4a63$var$expandRange = (args, options)=>{
    if (typeof options.expandRange === "function") return options.expandRange(...args, options);
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
        /* eslint-disable-next-line no-new */ new RegExp(value);
    } catch (ex) {
        return args.map((v)=>$5MQDC.escapeRegex(v)).join("..");
    }
    return value;
};
/**
 * Create the message for a syntax error
 */ const $fd5d6f248e5b4a63$var$syntaxError = (type, char)=>{
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */ const $fd5d6f248e5b4a63$var$parse = (input, options)=>{
    if (typeof input !== "string") throw new TypeError("Expected a string");
    input = $fd5d6f248e5b4a63$var$REPLACEMENTS[input] || input;
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($fd5d6f248e5b4a63$var$MAX_LENGTH, opts.maxLength) : $fd5d6f248e5b4a63$var$MAX_LENGTH;
    let len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    const bos = {
        type: "bos",
        value: "",
        output: opts.prepend || ""
    };
    const tokens = [
        bos
    ];
    const capture = opts.capture ? "" : "?:";
    const win32 = $5MQDC.isWindows(options);
    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = $7XmS6.globChars(win32);
    const EXTGLOB_CHARS = $7XmS6.extglobChars(PLATFORM_CHARS);
    const { DOT_LITERAL: DOT_LITERAL , PLUS_LITERAL: PLUS_LITERAL , SLASH_LITERAL: SLASH_LITERAL , ONE_CHAR: ONE_CHAR , DOTS_SLASH: DOTS_SLASH , NO_DOT: NO_DOT , NO_DOT_SLASH: NO_DOT_SLASH , NO_DOTS_SLASH: NO_DOTS_SLASH , QMARK: QMARK , QMARK_NO_DOT: QMARK_NO_DOT , STAR: STAR , START_ANCHOR: START_ANCHOR  } = PLATFORM_CHARS;
    const globstar = (opts)=>{
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) star = `(${star})`;
    // minimatch options support
    if (typeof opts.noext === "boolean") opts.noextglob = opts.noext;
    const state = {
        input: input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens: tokens
    };
    input = $5MQDC.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
   * Tokenizing helpers
   */ const eos = ()=>state.index === len - 1;
    const peek = state.peek = (n = 1)=>input[state.index + n];
    const advance = state.advance = ()=>input[++state.index] || "";
    const remaining = ()=>input.slice(state.index + 1);
    const consume = (value = "", num = 0)=>{
        state.consumed += value;
        state.index += num;
    };
    const append = (token)=>{
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    const negate = ()=>{
        let count = 1;
        while(peek() === "!" && (peek(2) !== "(" || peek(3) === "?")){
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) return false;
        state.negated = true;
        state.start++;
        return true;
    };
    const increment = (type)=>{
        state[type]++;
        stack.push(type);
    };
    const decrement = (type)=>{
        state[type]--;
        stack.pop();
    };
    /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */ const push = (tok)=>{
        if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = "star";
                prev.value = "*";
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== "paren") extglobs[extglobs.length - 1].inner += tok.value;
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    const extglobOpen = (type, value)=>{
        const token = {
            ...EXTGLOB_CHARS[value],
            conditions: 1,
            inner: ""
        };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({
            type: type,
            value: value,
            output: state.output ? "" : ONE_CHAR
        });
        push({
            type: "paren",
            extglob: true,
            value: advance(),
            output: output
        });
        extglobs.push(token);
    };
    const extglobClose = (token)=>{
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) extglobStar = globstar(opts);
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) output = token.close = `)$))${extglobStar}`;
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) output = token.close = `)${rest})${extglobStar})`;
            if (token.prev.type === "bos") state.negatedExtglob = true;
        }
        push({
            type: "paren",
            extglob: true,
            value: value,
            output: output
        });
        decrement("parens");
    };
    /**
   * Fast paths
   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace($fd5d6f248e5b4a63$var$REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
            if (first === "\\") {
                backslashes = true;
                return m;
            }
            if (first === "?") {
                if (esc) return esc + first + (rest ? QMARK.repeat(rest.length) : "");
                if (index === 0) return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
                return QMARK.repeat(chars.length);
            }
            if (first === ".") return DOT_LITERAL.repeat(chars.length);
            if (first === "*") {
                if (esc) return esc + first + (rest ? star : "");
                return star;
            }
            return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
            if (opts.unescape === true) output = output.replace(/\\/g, "");
            else output = output.replace(/\\+/g, (m)=>{
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = $5MQDC.wrapOutput(output, state, options);
        return state;
    }
    /**
   * Tokenize input until we reach end-of-string
   */ while(!eos()){
        value = advance();
        if (value === "\0") continue;
        /**
     * Escaped characters
     */ if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) continue;
            if (next === "." || next === ";") continue;
            if (!next) {
                value += "\\";
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) value += "\\";
            }
            if (opts.unescape === true) value = advance();
            else value += advance();
            if (state.brackets === 0) {
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
        }
        /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */ if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
                const inner = prev.value.slice(1);
                if (inner.includes("[")) {
                    prev.posix = true;
                    if (inner.includes(":")) {
                        const idx = prev.value.lastIndexOf("[");
                        const pre = prev.value.slice(0, idx);
                        const rest = prev.value.slice(idx + 2);
                        const posix = $fd5d6f248e5b4a63$var$POSIX_REGEX_SOURCE[rest];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) bos.output = ONE_CHAR;
                            continue;
                        }
                    }
                }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") value = `\\${value}`;
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) value = `\\${value}`;
            if (opts.posix === true && value === "!" && prev.value === "[") value = "^";
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */ if (state.quotes === 1 && value !== '"') {
            value = $5MQDC.escapeRegex(value);
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * Double quotes
     */ if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Parentheses
     */ if (value === "(") {
            increment("parens");
            push({
                type: "paren",
                value: value
            });
            continue;
        }
        if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("opening", "("));
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({
                type: "paren",
                value: value,
                output: state.parens ? ")" : "\\)"
            });
            decrement("parens");
            continue;
        }
        /**
     * Square brackets
     */ if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
                if (opts.nobracket !== true && opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "]"));
                value = `\\${value}`;
            } else increment("brackets");
            push({
                type: "bracket",
                value: value
            });
            continue;
        }
        if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("opening", "["));
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) value = `/${value}`;
            prev.value += value;
            append({
                value: value
            });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || $5MQDC.hasRegexChars(prevValue)) continue;
            const escaped = $5MQDC.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
        }
        /**
     * Braces
     */ if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
                type: "brace",
                value: value,
                output: "(",
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
        }
        if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
                push({
                    type: "text",
                    value: value,
                    output: value
                });
                continue;
            }
            let output1 = ")";
            if (brace.dots === true) {
                const arr = tokens.slice();
                const range = [];
                for(let i = arr.length - 1; i >= 0; i--){
                    tokens.pop();
                    if (arr[i].type === "brace") break;
                    if (arr[i].type !== "dots") range.unshift(arr[i].value);
                }
                output1 = $fd5d6f248e5b4a63$var$expandRange(range, opts);
                state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
                const out = state.output.slice(0, brace.outputIndex);
                const toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = "\\{";
                value = output1 = "\\}";
                state.output = out;
                for (const t of toks)state.output += t.output || t.value;
            }
            push({
                type: "brace",
                value: value,
                output: output1
            });
            decrement("braces");
            braces.pop();
            continue;
        }
        /**
     * Pipes
     */ if (value === "|") {
            if (extglobs.length > 0) extglobs[extglobs.length - 1].conditions++;
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Commas
     */ if (value === ",") {
            let output2 = value;
            const brace1 = braces[braces.length - 1];
            if (brace1 && stack[stack.length - 1] === "braces") {
                brace1.comma = true;
                output2 = "|";
            }
            push({
                type: "comma",
                value: value,
                output: output2
            });
            continue;
        }
        /**
     * Slashes
     */ if (value === "/") {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === "dot" && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = "";
                state.output = "";
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({
                type: "slash",
                value: value,
                output: SLASH_LITERAL
            });
            continue;
        }
        /**
     * Dots
     */ if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
                if (prev.value === ".") prev.output = DOT_LITERAL;
                const brace2 = braces[braces.length - 1];
                prev.type = "dots";
                prev.output += value;
                prev.value += value;
                brace2.dots = true;
                continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
                push({
                    type: "text",
                    value: value,
                    output: DOT_LITERAL
                });
                continue;
            }
            push({
                type: "dot",
                value: value,
                output: DOT_LITERAL
            });
            continue;
        }
        /**
     * Question marks
     */ if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("qmark", value);
                continue;
            }
            if (prev && prev.type === "paren") {
                const next1 = peek();
                let output3 = value;
                if (next1 === "<" && !$5MQDC.supportsLookbehinds()) throw new Error("Node.js v10 or higher is required for regex lookbehinds");
                if (prev.value === "(" && !/[!=<:]/.test(next1) || next1 === "<" && !/<([!=]|\w+>)/.test(remaining())) output3 = `\\${value}`;
                push({
                    type: "text",
                    value: value,
                    output: output3
                });
                continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
                push({
                    type: "qmark",
                    value: value,
                    output: QMARK_NO_DOT
                });
                continue;
            }
            push({
                type: "qmark",
                value: value,
                output: QMARK
            });
            continue;
        }
        /**
     * Exclamation
     */ if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
                if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                    extglobOpen("negate", value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate();
                continue;
            }
        }
        /**
     * Plus
     */ if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("plus", value);
                continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
                push({
                    type: "plus",
                    value: value,
                    output: PLUS_LITERAL
                });
                continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
                push({
                    type: "plus",
                    value: value
                });
                continue;
            }
            push({
                type: "plus",
                value: PLUS_LITERAL
            });
            continue;
        }
        /**
     * Plain text
     */ if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                push({
                    type: "at",
                    extglob: true,
                    value: value,
                    output: ""
                });
                continue;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Plain text
     */ if (value !== "*") {
            if (value === "$" || value === "^") value = `\\${value}`;
            const match1 = $fd5d6f248e5b4a63$var$REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match1) {
                value += match1[0];
                state.index += match1[0].length;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Stars
     */ if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
        }
        let rest1 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest1)) {
            extglobOpen("star", value);
            continue;
        }
        if (prev.type === "star") {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest1[0] && rest1[0] !== "/")) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            // strip consecutive `/**/`
            while(rest1.slice(0, 3) === "/**"){
                const after = input[state.index + 4];
                if (after && after !== "/") break;
                rest1 = rest1.slice(3);
                consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
                prev.type = "globstar";
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
                prev.value += value;
                state.globstar = true;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest1[0] === "/") {
                const end = rest1[1] !== void 0 ? "|$" : "";
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                prev.value += value;
                state.output += prior.output + prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            if (prior.type === "bos" && rest1[0] === "/") {
                prev.type = "globstar";
                prev.value += value;
                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                state.output = prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
        }
        const token = {
            type: "star",
            value: value,
            output: star
        };
        if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") token.output = nodot + token.output;
            push(token);
            continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            } else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== "*") {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while(state.brackets > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "]"));
        state.output = $5MQDC.escapeLast(state.output, "[");
        decrement("brackets");
    }
    while(state.parens > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", ")"));
        state.output = $5MQDC.escapeLast(state.output, "(");
        decrement("parens");
    }
    while(state.braces > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "}"));
        state.output = $5MQDC.escapeLast(state.output, "{");
        decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) push({
        type: "maybe_slash",
        value: "",
        output: `${SLASH_LITERAL}?`
    });
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = "";
        for (const token1 of state.tokens){
            state.output += token1.output != null ? token1.output : token1.value;
            if (token1.suffix) state.output += token1.suffix;
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */ $fd5d6f248e5b4a63$var$parse.fastpaths = (input, options)=>{
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($fd5d6f248e5b4a63$var$MAX_LENGTH, opts.maxLength) : $fd5d6f248e5b4a63$var$MAX_LENGTH;
    const len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    input = $fd5d6f248e5b4a63$var$REPLACEMENTS[input] || input;
    const win32 = $5MQDC.isWindows(options);
    // create constants based on platform, for windows or posix
    const { DOT_LITERAL: DOT_LITERAL , SLASH_LITERAL: SLASH_LITERAL , ONE_CHAR: ONE_CHAR , DOTS_SLASH: DOTS_SLASH , NO_DOT: NO_DOT , NO_DOTS: NO_DOTS , NO_DOTS_SLASH: NO_DOTS_SLASH , STAR: STAR , START_ANCHOR: START_ANCHOR  } = $7XmS6.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {
        negated: false,
        prefix: ""
    };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) star = `(${star})`;
    const globstar = (opts)=>{
        if (opts.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str)=>{
        switch(str){
            case "*":
                return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
                return nodot + globstar(opts);
            case "**/*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default:
                {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match) return;
                    const source = create(match[1]);
                    if (!source) return;
                    return source + DOT_LITERAL + match[2];
                }
        }
    };
    const output = $5MQDC.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) source += `${SLASH_LITERAL}?`;
    return source;
};
module.exports = $fd5d6f248e5b4a63$var$parse;

});


parcelRequire.register("5SlBN", function(module, exports) {
"use strict";

module.exports = (parcelRequire("5cGv8"));

module.exports.async = (parcelRequire("9s5mZ"));

module.exports.stream = (parcelRequire("kV1zV"));

module.exports.prettyError = (parcelRequire("ciuZ9"));

});
parcelRequire.register("5cGv8", function(module, exports) {
"use strict";
module.exports = $3c9f0a8fecf863f4$var$parseString;

var $1Sf6D = parcelRequire("1Sf6D");

var $ciuZ9 = parcelRequire("ciuZ9");
function $3c9f0a8fecf863f4$var$parseString(str) {
    if ($parcel$global.Buffer && $parcel$global.Buffer.isBuffer(str)) str = str.toString("utf8");
    const parser = new $1Sf6D();
    try {
        parser.parse(str);
        return parser.finish();
    } catch (err) {
        throw $ciuZ9(err, str);
    }
}

});
parcelRequire.register("1Sf6D", function(module, exports) {
"use strict";

/* eslint-disable no-new-wrappers, no-eval, camelcase, operator-linebreak */ module.exports = makeParserClass((parcelRequire("8E52p")));
module.exports.makeParserClass = makeParserClass;
class TomlError extends Error {
    constructor(msg){
        super(msg);
        this.name = "TomlError";
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, TomlError);
        this.fromTOML = true;
        this.wrapped = null;
    }
}
TomlError.wrap = (err)=>{
    const terr = new TomlError(err.message);
    terr.code = err.code;
    terr.wrapped = err;
    return terr;
};
module.exports.TomlError = TomlError;

var $bS2MF = parcelRequire("bS2MF");

var $9dYMx = parcelRequire("9dYMx");

var $gbrcb = parcelRequire("gbrcb");

var $636jz = parcelRequire("636jz");
const CTRL_I = 0x09;
const CTRL_J = 0x0A;
const CTRL_M = 0x0D;
const CTRL_CHAR_BOUNDARY = 0x1F // the last non-character in the latin1 region of unicode, except DEL
;
const CHAR_SP = 0x20;
const CHAR_QUOT = 0x22;
const CHAR_NUM = 0x23;
const CHAR_APOS = 0x27;
const CHAR_PLUS = 0x2B;
const CHAR_COMMA = 0x2C;
const CHAR_HYPHEN = 0x2D;
const CHAR_PERIOD = 0x2E;
const CHAR_0 = 0x30;
const CHAR_1 = 0x31;
const CHAR_7 = 0x37;
const CHAR_9 = 0x39;
const CHAR_COLON = 0x3A;
const CHAR_EQUALS = 0x3D;
const CHAR_A = 0x41;
const CHAR_E = 0x45;
const CHAR_F = 0x46;
const CHAR_T = 0x54;
const CHAR_U = 0x55;
const CHAR_Z = 0x5A;
const CHAR_LOWBAR = 0x5F;
const CHAR_a = 0x61;
const CHAR_b = 0x62;
const CHAR_e = 0x65;
const CHAR_f = 0x66;
const CHAR_i = 0x69;
const CHAR_l = 0x6C;
const CHAR_n = 0x6E;
const CHAR_o = 0x6F;
const CHAR_r = 0x72;
const CHAR_s = 0x73;
const CHAR_t = 0x74;
const CHAR_u = 0x75;
const CHAR_x = 0x78;
const CHAR_z = 0x7A;
const CHAR_LCUB = 0x7B;
const CHAR_RCUB = 0x7D;
const CHAR_LSQB = 0x5B;
const CHAR_BSOL = 0x5C;
const CHAR_RSQB = 0x5D;
const CHAR_DEL = 0x7F;
const SURROGATE_FIRST = 0xD800;
const SURROGATE_LAST = 0xDFFF;
const escapes = {
    [CHAR_b]: "\b",
    [CHAR_t]: "	",
    [CHAR_n]: "\n",
    [CHAR_f]: "\f",
    [CHAR_r]: "\r",
    [CHAR_QUOT]: '"',
    [CHAR_BSOL]: "\\"
};
function isDigit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_9;
}
function isHexit(cp) {
    return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
}
function isBit(cp) {
    return cp === CHAR_1 || cp === CHAR_0;
}
function isOctit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_7;
}
function isAlphaNumQuoteHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
function isAlphaNumHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
const _type = Symbol("type");
const _declared = Symbol("declared");
const hasOwnProperty = Object.prototype.hasOwnProperty;
const defineProperty = Object.defineProperty;
const descriptor = {
    configurable: true,
    enumerable: true,
    writable: true,
    value: undefined
};
function hasKey(obj, key) {
    if (hasOwnProperty.call(obj, key)) return true;
    if (key === "__proto__") defineProperty(obj, "__proto__", descriptor);
    return false;
}
const INLINE_TABLE = Symbol("inline-table");
function InlineTable() {
    return Object.defineProperties({}, {
        [_type]: {
            value: INLINE_TABLE
        }
    });
}
function isInlineTable(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INLINE_TABLE;
}
const TABLE = Symbol("table");
function Table() {
    return Object.defineProperties({}, {
        [_type]: {
            value: TABLE
        },
        [_declared]: {
            value: false,
            writable: true
        }
    });
}
function isTable(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === TABLE;
}
const _contentType = Symbol("content-type");
const INLINE_LIST = Symbol("inline-list");
function InlineList(type) {
    return Object.defineProperties([], {
        [_type]: {
            value: INLINE_LIST
        },
        [_contentType]: {
            value: type
        }
    });
}
function isInlineList(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INLINE_LIST;
}
const LIST = Symbol("list");
function List() {
    return Object.defineProperties([], {
        [_type]: {
            value: LIST
        }
    });
}
function isList(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === LIST;
}
// in an eval, to let bundlers not slurp in a util proxy
let _custom;
try {
    const utilInspect = eval("require('util').inspect");
    _custom = utilInspect.custom;
} catch (_) {
/* eval require not available in transpiled bundle */ }
/* istanbul ignore next */ const _inspect = _custom || "inspect";
class BoxedBigInt {
    constructor(value){
        try {
            this.value = $parcel$global.BigInt.asIntN(64, value);
        } catch (_) {
            /* istanbul ignore next */ this.value = null;
        }
        Object.defineProperty(this, _type, {
            value: INTEGER
        });
    }
    isNaN() {
        return this.value === null;
    }
    /* istanbul ignore next */ toString() {
        return String(this.value);
    }
    /* istanbul ignore next */ [_inspect]() {
        return `[BigInt: ${this.toString()}]}`;
    }
    valueOf() {
        return this.value;
    }
}
const INTEGER = Symbol("integer");
function Integer(value) {
    let num = Number(value);
    // -0 is a float thing, not an int thing
    if (Object.is(num, -0)) num = 0;
    /* istanbul ignore else */ if ($parcel$global.BigInt && !Number.isSafeInteger(num)) return new BoxedBigInt(value);
    else /* istanbul ignore next */ return Object.defineProperties(new Number(num), {
        isNaN: {
            value: function() {
                return isNaN(this);
            }
        },
        [_type]: {
            value: INTEGER
        },
        [_inspect]: {
            value: ()=>`[Integer: ${value}]`
        }
    });
}
function isInteger(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INTEGER;
}
const FLOAT = Symbol("float");
function Float(value) {
    /* istanbul ignore next */ return Object.defineProperties(new Number(value), {
        [_type]: {
            value: FLOAT
        },
        [_inspect]: {
            value: ()=>`[Float: ${value}]`
        }
    });
}
function isFloat(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === FLOAT;
}
function tomlType(value) {
    const type = typeof value;
    if (type === "object") {
        /* istanbul ignore if */ if (value === null) return "null";
        if (value instanceof Date) return "datetime";
        /* istanbul ignore else */ if (_type in value) switch(value[_type]){
            case INLINE_TABLE:
                return "inline-table";
            case INLINE_LIST:
                return "inline-list";
            /* istanbul ignore next */ case TABLE:
                return "table";
            /* istanbul ignore next */ case LIST:
                return "list";
            case FLOAT:
                return "float";
            case INTEGER:
                return "integer";
        }
    }
    return type;
}
function makeParserClass(Parser) {
    class TOMLParser extends Parser {
        constructor(){
            super();
            this.ctx = this.obj = Table();
        }
        /* MATCH HELPER */ atEndOfWord() {
            return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
        }
        atEndOfLine() {
            return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
        }
        parseStart() {
            if (this.char === Parser.END) return null;
            else if (this.char === CHAR_LSQB) return this.call(this.parseTableOrList);
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else if (isAlphaNumQuoteHyphen(this.char)) return this.callNow(this.parseAssignStatement);
            else throw this.error(new TomlError(`Unknown character "${this.char}"`));
        }
        // HELPER, this strips any whitespace and comments to the end of the line
        // then RETURNS. Last state in a production.
        parseWhitespaceToEOL() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else if (this.char === CHAR_NUM) return this.goto(this.parseComment);
            else if (this.char === Parser.END || this.char === CTRL_J) return this.return();
            else throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
        }
        /* ASSIGNMENT: key = value */ parseAssignStatement() {
            return this.callNow(this.parseAssign, this.recordAssignStatement);
        }
        recordAssignStatement(kv) {
            let target = this.ctx;
            let finalKey = kv.key.pop();
            for (let kw of kv.key){
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                target = target[kw] = target[kw] || Table();
            }
            if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
            // unbox our numbers
            if (isInteger(kv.value) || isFloat(kv.value)) target[finalKey] = kv.value.valueOf();
            else target[finalKey] = kv.value;
            return this.goto(this.parseWhitespaceToEOL);
        }
        /* ASSSIGNMENT expression, key = value possibly inside an inline table */ parseAssign() {
            return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        recordAssignKeyword(key) {
            if (this.state.resultTable) this.state.resultTable.push(key);
            else this.state.resultTable = [
                key
            ];
            return this.goto(this.parseAssignKeywordPreDot);
        }
        parseAssignKeywordPreDot() {
            if (this.char === CHAR_PERIOD) return this.next(this.parseAssignKeywordPostDot);
            else if (this.char !== CHAR_SP && this.char !== CTRL_I) return this.goto(this.parseAssignEqual);
        }
        parseAssignKeywordPostDot() {
            if (this.char !== CHAR_SP && this.char !== CTRL_I) return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        parseAssignEqual() {
            if (this.char === CHAR_EQUALS) return this.next(this.parseAssignPreValue);
            else throw this.error(new TomlError('Invalid character, expected "="'));
        }
        parseAssignPreValue() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseValue, this.recordAssignValue);
        }
        recordAssignValue(value) {
            return this.returnNow({
                key: this.state.resultTable,
                value: value
            });
        }
        /* COMMENTS: #...eol */ parseComment() {
            do {
                if (this.char === Parser.END || this.char === CTRL_J) return this.return();
            }while (this.nextChar());
        }
        /* TABLES AND LISTS, [foo] and [[foo]] */ parseTableOrList() {
            if (this.char === CHAR_LSQB) this.next(this.parseList);
            else return this.goto(this.parseTable);
        }
        /* TABLE [foo.bar.baz] */ parseTable() {
            this.ctx = this.obj;
            return this.goto(this.parseTableNext);
        }
        parseTableNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseKeyword, this.parseTableMore);
        }
        parseTableMore(keyword) {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CHAR_RSQB) {
                if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                else {
                    this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
                    this.ctx[_declared] = true;
                }
                return this.next(this.parseWhitespaceToEOL);
            } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) this.ctx = this.ctx[keyword] = Table();
                else if (isTable(this.ctx[keyword])) this.ctx = this.ctx[keyword];
                else if (isList(this.ctx[keyword])) this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                else throw this.error(new TomlError("Can't redefine existing key"));
                return this.next(this.parseTableNext);
            } else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* LIST [[a.b.c]] */ parseList() {
            this.ctx = this.obj;
            return this.goto(this.parseListNext);
        }
        parseListNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseKeyword, this.parseListMore);
        }
        parseListMore(keyword) {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CHAR_RSQB) {
                if (!hasKey(this.ctx, keyword)) this.ctx[keyword] = List();
                if (isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                else if (isList(this.ctx[keyword])) {
                    const next = Table();
                    this.ctx[keyword].push(next);
                    this.ctx = next;
                } else throw this.error(new TomlError("Can't redefine an existing key"));
                return this.next(this.parseListEnd);
            } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) this.ctx = this.ctx[keyword] = Table();
                else if (isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                else if (isInlineTable(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline table"));
                else if (isList(this.ctx[keyword])) this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                else if (isTable(this.ctx[keyword])) this.ctx = this.ctx[keyword];
                else throw this.error(new TomlError("Can't redefine an existing key"));
                return this.next(this.parseListNext);
            } else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        parseListEnd(keyword) {
            if (this.char === CHAR_RSQB) return this.next(this.parseWhitespaceToEOL);
            else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* VALUE string, number, boolean, inline list, inline object */ parseValue() {
            if (this.char === Parser.END) throw this.error(new TomlError("Key without value"));
            else if (this.char === CHAR_QUOT) return this.next(this.parseDoubleString);
            if (this.char === CHAR_APOS) return this.next(this.parseSingleString);
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) return this.goto(this.parseNumberSign);
            else if (this.char === CHAR_i) return this.next(this.parseInf);
            else if (this.char === CHAR_n) return this.next(this.parseNan);
            else if (isDigit(this.char)) return this.goto(this.parseNumberOrDateTime);
            else if (this.char === CHAR_t || this.char === CHAR_f) return this.goto(this.parseBoolean);
            else if (this.char === CHAR_LSQB) return this.call(this.parseInlineList, this.recordValue);
            else if (this.char === CHAR_LCUB) return this.call(this.parseInlineTable, this.recordValue);
            else throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
        }
        recordValue(value) {
            return this.returnNow(value);
        }
        parseInf() {
            if (this.char === CHAR_n) return this.next(this.parseInf2);
            else throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseInf2() {
            if (this.char === CHAR_f) {
                if (this.state.buf === "-") return this.return(-Infinity);
                else return this.return(Infinity);
            } else throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseNan() {
            if (this.char === CHAR_a) return this.next(this.parseNan2);
            else throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        parseNan2() {
            if (this.char === CHAR_n) return this.return(NaN);
            else throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        /* KEYS, barewords or basic, literal, or dotted */ parseKeyword() {
            if (this.char === CHAR_QUOT) return this.next(this.parseBasicString);
            else if (this.char === CHAR_APOS) return this.next(this.parseLiteralString);
            else return this.goto(this.parseBareKey);
        }
        /* KEYS: barewords */ parseBareKey() {
            do {
                if (this.char === Parser.END) throw this.error(new TomlError("Key ended without value"));
                else if (isAlphaNumHyphen(this.char)) this.consume();
                else if (this.state.buf.length === 0) throw this.error(new TomlError("Empty bare keys are not allowed"));
                else return this.returnNow();
            }while (this.nextChar());
        }
        /* STRINGS, single quoted (literal) */ parseSingleString() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiStringMaybe);
            else return this.goto(this.parseLiteralString);
        }
        parseLiteralString() {
            do {
                if (this.char === CHAR_APOS) return this.return();
                else if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        parseLiteralMultiStringMaybe() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiString);
            else return this.returnNow();
        }
        parseLiteralMultiString() {
            if (this.char === CTRL_M) return null;
            else if (this.char === CTRL_J) return this.next(this.parseLiteralMultiStringContent);
            else return this.goto(this.parseLiteralMultiStringContent);
        }
        parseLiteralMultiStringContent() {
            do {
                if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiEnd);
                else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        parseLiteralMultiEnd() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiEnd2);
            else {
                this.state.buf += "'";
                return this.goto(this.parseLiteralMultiStringContent);
            }
        }
        parseLiteralMultiEnd2() {
            if (this.char === CHAR_APOS) return this.return();
            else {
                this.state.buf += "''";
                return this.goto(this.parseLiteralMultiStringContent);
            }
        }
        /* STRINGS double quoted */ parseDoubleString() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiStringMaybe);
            else return this.goto(this.parseBasicString);
        }
        parseBasicString() {
            do {
                if (this.char === CHAR_BSOL) return this.call(this.parseEscape, this.recordEscapeReplacement);
                else if (this.char === CHAR_QUOT) return this.return();
                else if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        recordEscapeReplacement(replacement) {
            this.state.buf += replacement;
            return this.goto(this.parseBasicString);
        }
        parseMultiStringMaybe() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiString);
            else return this.returnNow();
        }
        parseMultiString() {
            if (this.char === CTRL_M) return null;
            else if (this.char === CTRL_J) return this.next(this.parseMultiStringContent);
            else return this.goto(this.parseMultiStringContent);
        }
        parseMultiStringContent() {
            do {
                if (this.char === CHAR_BSOL) return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
                else if (this.char === CHAR_QUOT) return this.next(this.parseMultiEnd);
                else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        errorControlCharInString() {
            let displayCode = "\\u00";
            if (this.char < 16) displayCode += "0";
            displayCode += this.char.toString(16);
            return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
        }
        recordMultiEscapeReplacement(replacement) {
            this.state.buf += replacement;
            return this.goto(this.parseMultiStringContent);
        }
        parseMultiEnd() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiEnd2);
            else {
                this.state.buf += '"';
                return this.goto(this.parseMultiStringContent);
            }
        }
        parseMultiEnd2() {
            if (this.char === CHAR_QUOT) return this.return();
            else {
                this.state.buf += '""';
                return this.goto(this.parseMultiStringContent);
            }
        }
        parseMultiEscape() {
            if (this.char === CTRL_M || this.char === CTRL_J) return this.next(this.parseMultiTrim);
            else if (this.char === CHAR_SP || this.char === CTRL_I) return this.next(this.parsePreMultiTrim);
            else return this.goto(this.parseEscape);
        }
        parsePreMultiTrim() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CTRL_M || this.char === CTRL_J) return this.next(this.parseMultiTrim);
            else throw this.error(new TomlError("Can't escape whitespace"));
        }
        parseMultiTrim() {
            // explicitly whitespace here, END should follow the same path as chars
            if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else return this.returnNow();
        }
        parseEscape() {
            if (this.char in escapes) return this.return(escapes[this.char]);
            else if (this.char === CHAR_u) return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
            else if (this.char === CHAR_U) return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
            else throw this.error(new TomlError("Unknown escape character: " + this.char));
        }
        parseUnicodeReturn(char) {
            try {
                const codePoint = parseInt(char, 16);
                if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
                return this.returnNow(String.fromCodePoint(codePoint));
            } catch (err) {
                throw this.error(TomlError.wrap(err));
            }
        }
        parseSmallUnicode() {
            if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
            else {
                this.consume();
                if (this.state.buf.length >= 4) return this.return();
            }
        }
        parseLargeUnicode() {
            if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
            else {
                this.consume();
                if (this.state.buf.length >= 8) return this.return();
            }
        }
        /* NUMBERS */ parseNumberSign() {
            this.consume();
            return this.next(this.parseMaybeSignedInfOrNan);
        }
        parseMaybeSignedInfOrNan() {
            if (this.char === CHAR_i) return this.next(this.parseInf);
            else if (this.char === CHAR_n) return this.next(this.parseNan);
            else return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
        }
        parseNumberIntegerStart() {
            if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberIntegerExponentOrDecimal);
            } else return this.goto(this.parseNumberInteger);
        }
        parseNumberIntegerExponentOrDecimal() {
            if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else return this.returnNow(Integer(this.state.buf));
        }
        parseNumberInteger() {
            if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseNoUnder() {
            if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) throw this.error(new TomlError("Unexpected character, expected digit"));
            else if (this.atEndOfWord()) throw this.error(new TomlError("Incomplete number"));
            return this.returnNow();
        }
        parseNumberFloat() {
            if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder, this.parseNumberFloat);
            else if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else return this.returnNow(Float(this.state.buf));
        }
        parseNumberExponentSign() {
            if (isDigit(this.char)) return this.goto(this.parseNumberExponent);
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.call(this.parseNoUnder, this.parseNumberExponent);
            } else throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
        }
        parseNumberExponent() {
            if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else return this.returnNow(Float(this.state.buf));
        }
        /* NUMBERS or DATETIMES  */ parseNumberOrDateTime() {
            if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberBaseOrDateTime);
            } else return this.goto(this.parseNumberOrDateTimeOnly);
        }
        parseNumberOrDateTimeOnly() {
            // note, if two zeros are in a row then it MUST be a date
            if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder, this.parseNumberInteger);
            else if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length > 4) this.next(this.parseNumberInteger);
            } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else if (this.char === CHAR_HYPHEN) return this.goto(this.parseDateTime);
            else if (this.char === CHAR_COLON) return this.goto(this.parseOnlyTimeHour);
            else return this.returnNow(Integer(this.state.buf));
        }
        parseDateTimeOnly() {
            if (this.state.buf.length < 4) {
                if (isDigit(this.char)) return this.consume();
                else if (this.char === CHAR_COLON) return this.goto(this.parseOnlyTimeHour);
                else throw this.error(new TomlError("Expected digit while parsing year part of a date"));
            } else {
                if (this.char === CHAR_HYPHEN) return this.goto(this.parseDateTime);
                else throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
            }
        }
        parseNumberBaseOrDateTime() {
            if (this.char === CHAR_b) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerBin);
            } else if (this.char === CHAR_o) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerOct);
            } else if (this.char === CHAR_x) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerHex);
            } else if (this.char === CHAR_PERIOD) return this.goto(this.parseNumberInteger);
            else if (isDigit(this.char)) return this.goto(this.parseDateTimeOnly);
            else return this.returnNow(Integer(this.state.buf));
        }
        parseIntegerHex() {
            if (isHexit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseIntegerOct() {
            if (isOctit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseIntegerBin() {
            if (isBit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        /* DATETIME */ parseDateTime() {
            // we enter here having just consumed the year and about to consume the hyphen
            if (this.state.buf.length < 4) throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
            this.state.result = this.state.buf;
            this.state.buf = "";
            return this.next(this.parseDateMonth);
        }
        parseDateMonth() {
            if (this.char === CHAR_HYPHEN) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseDateDay);
            } else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseDateDay() {
            if (this.char === CHAR_T || this.char === CHAR_SP) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseStartTimeHour);
            } else if (this.atEndOfWord()) return this.return($gbrcb(this.state.result + "-" + this.state.buf));
            else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseStartTimeHour() {
            if (this.atEndOfWord()) return this.returnNow($gbrcb(this.state.result));
            else return this.goto(this.parseTimeHour);
        }
        parseTimeHour() {
            if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                this.state.result += "T" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeMin);
            } else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseTimeMin() {
            if (this.state.buf.length < 2 && isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeSec);
            } else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseTimeSec() {
            if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) {
                    this.state.result += ":" + this.state.buf;
                    this.state.buf = "";
                    return this.next(this.parseTimeZoneOrFraction);
                }
            } else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseOnlyTimeHour() {
            /* istanbul ignore else */ if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                this.state.result = this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeMin);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeMin() {
            if (this.state.buf.length < 2 && isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeSec);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeSec() {
            if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) return this.next(this.parseOnlyTimeFractionMaybe);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeFractionMaybe() {
            this.state.result += ":" + this.state.buf;
            if (this.char === CHAR_PERIOD) {
                this.state.buf = "";
                this.next(this.parseOnlyTimeFraction);
            } else return this.return($636jz(this.state.result));
        }
        parseOnlyTimeFraction() {
            if (isDigit(this.char)) this.consume();
            else if (this.atEndOfWord()) {
                if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
                return this.returnNow($636jz(this.state.result + "." + this.state.buf));
            } else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseTimeZoneOrFraction() {
            if (this.char === CHAR_PERIOD) {
                this.consume();
                this.next(this.parseDateTimeFraction);
            } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
            } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return($bS2MF(this.state.result + this.state.buf));
            } else if (this.atEndOfWord()) return this.returnNow($9dYMx(this.state.result + this.state.buf));
            else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseDateTimeFraction() {
            if (isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 1) throw this.error(new TomlError("Expected digit in milliseconds"));
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
            } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return($bS2MF(this.state.result + this.state.buf));
            } else if (this.atEndOfWord()) return this.returnNow($9dYMx(this.state.result + this.state.buf));
            else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseTimeZoneHour() {
            if (isDigit(this.char)) {
                this.consume();
                // FIXME: No more regexps
                if (/\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
            } else throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        parseTimeZoneSep() {
            if (this.char === CHAR_COLON) {
                this.consume();
                this.next(this.parseTimeZoneMin);
            } else throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
        }
        parseTimeZoneMin() {
            if (isDigit(this.char)) {
                this.consume();
                if (/\d\d$/.test(this.state.buf)) return this.return($bS2MF(this.state.result + this.state.buf));
            } else throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        /* BOOLEAN */ parseBoolean() {
            /* istanbul ignore else */ if (this.char === CHAR_t) {
                this.consume();
                return this.next(this.parseTrue_r);
            } else if (this.char === CHAR_f) {
                this.consume();
                return this.next(this.parseFalse_a);
            }
        }
        parseTrue_r() {
            if (this.char === CHAR_r) {
                this.consume();
                return this.next(this.parseTrue_u);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_u() {
            if (this.char === CHAR_u) {
                this.consume();
                return this.next(this.parseTrue_e);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_e() {
            if (this.char === CHAR_e) return this.return(true);
            else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_a() {
            if (this.char === CHAR_a) {
                this.consume();
                return this.next(this.parseFalse_l);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_l() {
            if (this.char === CHAR_l) {
                this.consume();
                return this.next(this.parseFalse_s);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_s() {
            if (this.char === CHAR_s) {
                this.consume();
                return this.next(this.parseFalse_e);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_e() {
            if (this.char === CHAR_e) return this.return(false);
            else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        /* INLINE LISTS */ parseInlineList() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
            else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CHAR_RSQB) return this.return(this.state.resultArr || InlineList());
            else return this.callNow(this.parseValue, this.recordInlineListValue);
        }
        recordInlineListValue(value) {
            if (this.state.resultArr) {
                const listType = this.state.resultArr[_contentType];
                const valueType = tomlType(value);
                if (listType !== valueType) throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
            } else this.state.resultArr = InlineList(tomlType(value));
            if (isFloat(value) || isInteger(value)) // unbox now that we've verified they're ok
            this.state.resultArr.push(value.valueOf());
            else this.state.resultArr.push(value);
            return this.goto(this.parseInlineListNext);
        }
        parseInlineListNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CHAR_COMMA) return this.next(this.parseInlineList);
            else if (this.char === CHAR_RSQB) return this.goto(this.parseInlineList);
            else throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
        /* INLINE TABLE */ parseInlineTable() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_RCUB) return this.return(this.state.resultTable || InlineTable());
            else {
                if (!this.state.resultTable) this.state.resultTable = InlineTable();
                return this.callNow(this.parseAssign, this.recordInlineTableValue);
            }
        }
        recordInlineTableValue(kv) {
            let target = this.state.resultTable;
            let finalKey = kv.key.pop();
            for (let kw of kv.key){
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                target = target[kw] = target[kw] || Table();
            }
            if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
            if (isInteger(kv.value) || isFloat(kv.value)) target[finalKey] = kv.value.valueOf();
            else target[finalKey] = kv.value;
            return this.goto(this.parseInlineTableNext);
        }
        parseInlineTableNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_COMMA) return this.next(this.parseInlineTable);
            else if (this.char === CHAR_RCUB) return this.goto(this.parseInlineTable);
            else throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
    }
    return TOMLParser;
}

});
parcelRequire.register("8E52p", function(module, exports) {
"use strict";
const $64b5f7964fcf57fb$var$ParserEND = 0x110000;
class $64b5f7964fcf57fb$var$ParserError extends Error {
    /* istanbul ignore next */ constructor(msg, filename, linenumber){
        super("[ParserError] " + msg, filename, linenumber);
        this.name = "ParserError";
        this.code = "ParserError";
        if (Error.captureStackTrace) Error.captureStackTrace(this, $64b5f7964fcf57fb$var$ParserError);
    }
}
class $64b5f7964fcf57fb$var$State {
    constructor(parser){
        this.parser = parser;
        this.buf = "";
        this.returned = null;
        this.result = null;
        this.resultTable = null;
        this.resultArr = null;
    }
}
class $64b5f7964fcf57fb$var$Parser {
    constructor(){
        this.pos = 0;
        this.col = 0;
        this.line = 0;
        this.obj = {};
        this.ctx = this.obj;
        this.stack = [];
        this._buf = "";
        this.char = null;
        this.ii = 0;
        this.state = new $64b5f7964fcf57fb$var$State(this.parseStart);
    }
    parse(str) {
        /* istanbul ignore next */ if (str.length === 0 || str.length == null) return;
        this._buf = String(str);
        this.ii = -1;
        this.char = -1;
        let getNext;
        while(getNext === false || this.nextChar())getNext = this.runOne();
        this._buf = null;
    }
    nextChar() {
        if (this.char === 0x0A) {
            ++this.line;
            this.col = -1;
        }
        ++this.ii;
        this.char = this._buf.codePointAt(this.ii);
        ++this.pos;
        ++this.col;
        return this.haveBuffer();
    }
    haveBuffer() {
        return this.ii < this._buf.length;
    }
    runOne() {
        return this.state.parser.call(this, this.state.returned);
    }
    finish() {
        this.char = $64b5f7964fcf57fb$var$ParserEND;
        let last;
        do {
            last = this.state.parser;
            this.runOne();
        }while (this.state.parser !== last);
        this.ctx = null;
        this.state = null;
        this._buf = null;
        return this.obj;
    }
    next(fn) {
        /* istanbul ignore next */ if (typeof fn !== "function") throw new $64b5f7964fcf57fb$var$ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
        this.state.parser = fn;
    }
    goto(fn) {
        this.next(fn);
        return this.runOne();
    }
    call(fn, returnWith) {
        if (returnWith) this.next(returnWith);
        this.stack.push(this.state);
        this.state = new $64b5f7964fcf57fb$var$State(fn);
    }
    callNow(fn, returnWith) {
        this.call(fn, returnWith);
        return this.runOne();
    }
    return(value) {
        /* istanbul ignore next */ if (this.stack.length === 0) throw this.error(new $64b5f7964fcf57fb$var$ParserError("Stack underflow"));
        if (value === undefined) value = this.state.buf;
        this.state = this.stack.pop();
        this.state.returned = value;
    }
    returnNow(value) {
        this.return(value);
        return this.runOne();
    }
    consume() {
        /* istanbul ignore next */ if (this.char === $64b5f7964fcf57fb$var$ParserEND) throw this.error(new $64b5f7964fcf57fb$var$ParserError("Unexpected end-of-buffer"));
        this.state.buf += this._buf[this.ii];
    }
    error(err) {
        err.line = this.line;
        err.col = this.col;
        err.pos = this.pos;
        return err;
    }
    /* istanbul ignore next */ parseStart() {
        throw new $64b5f7964fcf57fb$var$ParserError("Must declare a parseStart method");
    }
}
$64b5f7964fcf57fb$var$Parser.END = $64b5f7964fcf57fb$var$ParserEND;
$64b5f7964fcf57fb$var$Parser.Error = $64b5f7964fcf57fb$var$ParserError;
module.exports = $64b5f7964fcf57fb$var$Parser;

});

parcelRequire.register("bS2MF", function(module, exports) {
"use strict";
module.exports = (value)=>{
    const date = new Date(value);
    /* istanbul ignore if */ if (isNaN(date)) throw new TypeError("Invalid Datetime");
    else return date;
};

});

parcelRequire.register("9dYMx", function(module, exports) {
"use strict";

var $1ThAX = parcelRequire("1ThAX");
class $6b7479f98c0b0f2e$var$FloatingDateTime extends Date {
    constructor(value){
        super(value + "Z");
        this.isFloating = true;
    }
    toISOString() {
        const date = `${this.getUTCFullYear()}-${$1ThAX(2, this.getUTCMonth() + 1)}-${$1ThAX(2, this.getUTCDate())}`;
        const time = `${$1ThAX(2, this.getUTCHours())}:${$1ThAX(2, this.getUTCMinutes())}:${$1ThAX(2, this.getUTCSeconds())}.${$1ThAX(3, this.getUTCMilliseconds())}`;
        return `${date}T${time}`;
    }
}
module.exports = (value)=>{
    const date = new $6b7479f98c0b0f2e$var$FloatingDateTime(value);
    /* istanbul ignore if */ if (isNaN(date)) throw new TypeError("Invalid Datetime");
    else return date;
};

});
parcelRequire.register("1ThAX", function(module, exports) {
"use strict";
module.exports = (d, num)=>{
    num = String(num);
    while(num.length < d)num = "0" + num;
    return num;
};

});


parcelRequire.register("gbrcb", function(module, exports) {
"use strict";

var $1ThAX = parcelRequire("1ThAX");
const $bc82c4de3669a4d8$var$DateTime = $parcel$global.Date;
class $bc82c4de3669a4d8$var$Date extends $bc82c4de3669a4d8$var$DateTime {
    constructor(value){
        super(value);
        this.isDate = true;
    }
    toISOString() {
        return `${this.getUTCFullYear()}-${$1ThAX(2, this.getUTCMonth() + 1)}-${$1ThAX(2, this.getUTCDate())}`;
    }
}
module.exports = (value)=>{
    const date = new $bc82c4de3669a4d8$var$Date(value);
    /* istanbul ignore if */ if (isNaN(date)) throw new TypeError("Invalid Datetime");
    else return date;
};

});

parcelRequire.register("636jz", function(module, exports) {
"use strict";

var $1ThAX = parcelRequire("1ThAX");
class $4677ebdc0d7530bb$var$Time extends Date {
    constructor(value){
        super(`0000-01-01T${value}Z`);
        this.isTime = true;
    }
    toISOString() {
        return `${$1ThAX(2, this.getUTCHours())}:${$1ThAX(2, this.getUTCMinutes())}:${$1ThAX(2, this.getUTCSeconds())}.${$1ThAX(3, this.getUTCMilliseconds())}`;
    }
}
module.exports = (value)=>{
    const date = new $4677ebdc0d7530bb$var$Time(value);
    /* istanbul ignore if */ if (isNaN(date)) throw new TypeError("Invalid Datetime");
    else return date;
};

});


parcelRequire.register("ciuZ9", function(module, exports) {
"use strict";
module.exports = $8f3f337e029ee933$var$prettyError;
function $8f3f337e029ee933$var$prettyError(err, buf) {
    /* istanbul ignore if */ if (err.pos == null || err.line == null) return err;
    let msg = err.message;
    msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`;
    /* istanbul ignore else */ if (buf && buf.split) {
        const lines = buf.split(/\n/);
        const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
        let linePadding = " ";
        while(linePadding.length < lineNumWidth)linePadding += " ";
        for(let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii){
            let lineNum = String(ii + 1);
            if (lineNum.length < lineNumWidth) lineNum = " " + lineNum;
            if (err.line === ii) {
                msg += lineNum + "> " + lines[ii] + "\n";
                msg += linePadding + "  ";
                for(let hh = 0; hh < err.col; ++hh)msg += " ";
                msg += "^\n";
            } else msg += lineNum + ": " + lines[ii] + "\n";
        }
    }
    err.message = msg + "\n";
    return err;
}

});


parcelRequire.register("9s5mZ", function(module, exports) {
"use strict";
module.exports = $6e1ae4ed5b62d1d9$var$parseAsync;

var $1Sf6D = parcelRequire("1Sf6D");

var $ciuZ9 = parcelRequire("ciuZ9");
function $6e1ae4ed5b62d1d9$var$parseAsync(str, opts) {
    if (!opts) opts = {};
    const index = 0;
    const blocksize = opts.blocksize || 40960;
    const parser = new $1Sf6D();
    return new Promise((resolve, reject)=>{
        setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
    });
    function parseAsyncNext(index, blocksize, resolve, reject) {
        if (index >= str.length) try {
            return resolve(parser.finish());
        } catch (err) {
            return reject($ciuZ9(err, str));
        }
        try {
            parser.parse(str.slice(index, index + blocksize));
            setImmediate(parseAsyncNext, index + blocksize, blocksize, resolve, reject);
        } catch (err1) {
            reject($ciuZ9(err1, str));
        }
    }
}

});

parcelRequire.register("kV1zV", function(module, exports) {
"use strict";
module.exports = $f3aa5afcf94fb65f$var$parseStream;


var $1Sf6D = parcelRequire("1Sf6D");
function $f3aa5afcf94fb65f$var$parseStream(stm) {
    if (stm) return $f3aa5afcf94fb65f$var$parseReadable(stm);
    else return $f3aa5afcf94fb65f$var$parseTransform(stm);
}
function $f3aa5afcf94fb65f$var$parseReadable(stm) {
    const parser = new $1Sf6D();
    stm.setEncoding("utf8");
    return new Promise((resolve, reject)=>{
        let readable;
        let ended = false;
        let errored = false;
        function finish() {
            ended = true;
            if (readable) return;
            try {
                resolve(parser.finish());
            } catch (err) {
                reject(err);
            }
        }
        function error(err) {
            errored = true;
            reject(err);
        }
        stm.once("end", finish);
        stm.once("error", error);
        readNext();
        function readNext() {
            readable = true;
            let data;
            while((data = stm.read()) !== null)try {
                parser.parse(data);
            } catch (err) {
                return error(err);
            }
            readable = false;
            /* istanbul ignore if */ if (ended) return finish();
            /* istanbul ignore if */ if (errored) return;
            stm.once("readable", readNext);
        }
    });
}
function $f3aa5afcf94fb65f$var$parseTransform() {
    const parser = new $1Sf6D();
    return new $8C1kk$stream.Transform({
        objectMode: true,
        transform (chunk, encoding, cb) {
            try {
                parser.parse(chunk.toString(encoding));
            } catch (err) {
                this.emit("error", err);
            }
            cb();
        },
        flush (cb) {
            try {
                this.push(parser.finish());
            } catch (err) {
                this.emit("error", err);
            }
            cb();
        }
    });
}

});


parcelRequire.register("224JI", function(module, exports) {
"use strict";
module.exports = $17af713ce388fcb8$var$stringify;
module.exports.value = $17af713ce388fcb8$var$stringifyInline;
function $17af713ce388fcb8$var$stringify(obj) {
    if (obj === null) throw $17af713ce388fcb8$var$typeError("null");
    if (obj === void 0) throw $17af713ce388fcb8$var$typeError("undefined");
    if (typeof obj !== "object") throw $17af713ce388fcb8$var$typeError(typeof obj);
    if (typeof obj.toJSON === "function") obj = obj.toJSON();
    if (obj == null) return null;
    const type = $17af713ce388fcb8$var$tomlType(obj);
    if (type !== "table") throw $17af713ce388fcb8$var$typeError(type);
    return $17af713ce388fcb8$var$stringifyObject("", "", obj);
}
function $17af713ce388fcb8$var$typeError(type) {
    return new Error("Can only stringify objects, not " + type);
}
function $17af713ce388fcb8$var$arrayOneTypeError() {
    return new Error("Array values can't have mixed types");
}
function $17af713ce388fcb8$var$getInlineKeys(obj) {
    return Object.keys(obj).filter((key)=>$17af713ce388fcb8$var$isInline(obj[key]));
}
function $17af713ce388fcb8$var$getComplexKeys(obj) {
    return Object.keys(obj).filter((key)=>!$17af713ce388fcb8$var$isInline(obj[key]));
}
function $17af713ce388fcb8$var$toJSON(obj) {
    let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? {
        ["__proto__"]: undefined
    } : {};
    for (let prop of Object.keys(obj))if (obj[prop] && typeof obj[prop].toJSON === "function" && !("toISOString" in obj[prop])) nobj[prop] = obj[prop].toJSON();
    else nobj[prop] = obj[prop];
    return nobj;
}
function $17af713ce388fcb8$var$stringifyObject(prefix, indent, obj) {
    obj = $17af713ce388fcb8$var$toJSON(obj);
    var inlineKeys;
    var complexKeys;
    inlineKeys = $17af713ce388fcb8$var$getInlineKeys(obj);
    complexKeys = $17af713ce388fcb8$var$getComplexKeys(obj);
    var result = [];
    var inlineIndent = indent || "";
    inlineKeys.forEach((key)=>{
        var type = $17af713ce388fcb8$var$tomlType(obj[key]);
        if (type !== "undefined" && type !== "null") result.push(inlineIndent + $17af713ce388fcb8$var$stringifyKey(key) + " = " + $17af713ce388fcb8$var$stringifyAnyInline(obj[key], true));
    });
    if (result.length > 0) result.push("");
    var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
    complexKeys.forEach((key)=>{
        result.push($17af713ce388fcb8$var$stringifyComplex(prefix, complexIndent, key, obj[key]));
    });
    return result.join("\n");
}
function $17af713ce388fcb8$var$isInline(value) {
    switch($17af713ce388fcb8$var$tomlType(value)){
        case "undefined":
        case "null":
        case "integer":
        case "nan":
        case "float":
        case "boolean":
        case "string":
        case "datetime":
            return true;
        case "array":
            return value.length === 0 || $17af713ce388fcb8$var$tomlType(value[0]) !== "table";
        case "table":
            return Object.keys(value).length === 0;
        /* istanbul ignore next */ default:
            return false;
    }
}
function $17af713ce388fcb8$var$tomlType(value) {
    if (value === undefined) return "undefined";
    else if (value === null) return "null";
    else if (typeof value === "bigint" || Number.isInteger(value) && !Object.is(value, -0)) return "integer";
    else if (typeof value === "number") return "float";
    else if (typeof value === "boolean") return "boolean";
    else if (typeof value === "string") return "string";
    else if ("toISOString" in value) return isNaN(value) ? "undefined" : "datetime";
    else if (Array.isArray(value)) return "array";
    else return "table";
}
function $17af713ce388fcb8$var$stringifyKey(key) {
    var keyStr = String(key);
    if (/^[-A-Za-z0-9_]+$/.test(keyStr)) return keyStr;
    else return $17af713ce388fcb8$var$stringifyBasicString(keyStr);
}
function $17af713ce388fcb8$var$stringifyBasicString(str) {
    return '"' + $17af713ce388fcb8$var$escapeString(str).replace(/"/g, '\\"') + '"';
}
function $17af713ce388fcb8$var$stringifyLiteralString(str) {
    return "'" + str + "'";
}
function $17af713ce388fcb8$var$numpad(num, str) {
    while(str.length < num)str = "0" + str;
    return str;
}
function $17af713ce388fcb8$var$escapeString(str) {
    return str.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r")/* eslint-disable no-control-regex */ .replace(/([\u0000-\u001f\u007f])/, (c)=>"\\u" + $17af713ce388fcb8$var$numpad(4, c.codePointAt(0).toString(16)));
/* eslint-enable no-control-regex */ }
function $17af713ce388fcb8$var$stringifyMultilineString(str) {
    let escaped = str.split(/\n/).map((str)=>{
        return $17af713ce388fcb8$var$escapeString(str).replace(/"(?="")/g, '\\"');
    }).join("\n");
    if (escaped.slice(-1) === '"') escaped += "\\\n";
    return '"""\n' + escaped + '"""';
}
function $17af713ce388fcb8$var$stringifyAnyInline(value, multilineOk) {
    let type = $17af713ce388fcb8$var$tomlType(value);
    if (type === "string") {
        if (multilineOk && /\n/.test(value)) type = "string-multiline";
        else if (!/[\b\t\n\f\r']/.test(value) && /"/.test(value)) type = "string-literal";
    }
    return $17af713ce388fcb8$var$stringifyInline(value, type);
}
function $17af713ce388fcb8$var$stringifyInline(value, type) {
    /* istanbul ignore if */ if (!type) type = $17af713ce388fcb8$var$tomlType(value);
    switch(type){
        case "string-multiline":
            return $17af713ce388fcb8$var$stringifyMultilineString(value);
        case "string":
            return $17af713ce388fcb8$var$stringifyBasicString(value);
        case "string-literal":
            return $17af713ce388fcb8$var$stringifyLiteralString(value);
        case "integer":
            return $17af713ce388fcb8$var$stringifyInteger(value);
        case "float":
            return $17af713ce388fcb8$var$stringifyFloat(value);
        case "boolean":
            return $17af713ce388fcb8$var$stringifyBoolean(value);
        case "datetime":
            return $17af713ce388fcb8$var$stringifyDatetime(value);
        case "array":
            return $17af713ce388fcb8$var$stringifyInlineArray(value.filter((_)=>$17af713ce388fcb8$var$tomlType(_) !== "null" && $17af713ce388fcb8$var$tomlType(_) !== "undefined" && $17af713ce388fcb8$var$tomlType(_) !== "nan"));
        case "table":
            return $17af713ce388fcb8$var$stringifyInlineTable(value);
        /* istanbul ignore next */ default:
            throw $17af713ce388fcb8$var$typeError(type);
    }
}
function $17af713ce388fcb8$var$stringifyInteger(value) {
    /* eslint-disable security/detect-unsafe-regex */ return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
}
function $17af713ce388fcb8$var$stringifyFloat(value) {
    if (value === Infinity) return "inf";
    else if (value === -Infinity) return "-inf";
    else if (Object.is(value, NaN)) return "nan";
    else if (Object.is(value, -0)) return "-0.0";
    var chunks = String(value).split(".");
    var int = chunks[0];
    var dec = chunks[1] || 0;
    return $17af713ce388fcb8$var$stringifyInteger(int) + "." + dec;
}
function $17af713ce388fcb8$var$stringifyBoolean(value) {
    return String(value);
}
function $17af713ce388fcb8$var$stringifyDatetime(value) {
    return value.toISOString();
}
function $17af713ce388fcb8$var$isNumber(type) {
    return type === "float" || type === "integer";
}
function $17af713ce388fcb8$var$arrayType(values) {
    var contentType = $17af713ce388fcb8$var$tomlType(values[0]);
    if (values.every((_)=>$17af713ce388fcb8$var$tomlType(_) === contentType)) return contentType;
    // mixed integer/float, emit as floats
    if (values.every((_)=>$17af713ce388fcb8$var$isNumber($17af713ce388fcb8$var$tomlType(_)))) return "float";
    return "mixed";
}
function $17af713ce388fcb8$var$validateArray(values) {
    const type = $17af713ce388fcb8$var$arrayType(values);
    if (type === "mixed") throw $17af713ce388fcb8$var$arrayOneTypeError();
    return type;
}
function $17af713ce388fcb8$var$stringifyInlineArray(values) {
    values = $17af713ce388fcb8$var$toJSON(values);
    const type = $17af713ce388fcb8$var$validateArray(values);
    var result = "[";
    var stringified = values.map((_)=>$17af713ce388fcb8$var$stringifyInline(_, type));
    if (stringified.join(", ").length > 60 || /\n/.test(stringified)) result += "\n  " + stringified.join(",\n  ") + "\n";
    else result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : "");
    return result + "]";
}
function $17af713ce388fcb8$var$stringifyInlineTable(value) {
    value = $17af713ce388fcb8$var$toJSON(value);
    var result = [];
    Object.keys(value).forEach((key)=>{
        result.push($17af713ce388fcb8$var$stringifyKey(key) + " = " + $17af713ce388fcb8$var$stringifyAnyInline(value[key], false));
    });
    return "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
}
function $17af713ce388fcb8$var$stringifyComplex(prefix, indent, key, value) {
    var valueType = $17af713ce388fcb8$var$tomlType(value);
    /* istanbul ignore else */ if (valueType === "array") return $17af713ce388fcb8$var$stringifyArrayOfTables(prefix, indent, key, value);
    else if (valueType === "table") return $17af713ce388fcb8$var$stringifyComplexTable(prefix, indent, key, value);
    else throw $17af713ce388fcb8$var$typeError(valueType);
}
function $17af713ce388fcb8$var$stringifyArrayOfTables(prefix, indent, key, values) {
    values = $17af713ce388fcb8$var$toJSON(values);
    $17af713ce388fcb8$var$validateArray(values);
    var firstValueType = $17af713ce388fcb8$var$tomlType(values[0]);
    /* istanbul ignore if */ if (firstValueType !== "table") throw $17af713ce388fcb8$var$typeError(firstValueType);
    var fullKey = prefix + $17af713ce388fcb8$var$stringifyKey(key);
    var result = "";
    values.forEach((table)=>{
        if (result.length > 0) result += "\n";
        result += indent + "[[" + fullKey + "]]\n";
        result += $17af713ce388fcb8$var$stringifyObject(fullKey + ".", indent, table);
    });
    return result;
}
function $17af713ce388fcb8$var$stringifyComplexTable(prefix, indent, key, value) {
    var fullKey = prefix + $17af713ce388fcb8$var$stringifyKey(key);
    var result = "";
    if ($17af713ce388fcb8$var$getInlineKeys(value).length > 0) result += indent + "[" + fullKey + "]\n";
    return result + $17af713ce388fcb8$var$stringifyObject(fullKey + ".", indent, value);
}

});

parcelRequire.register("lADnf", function(module, exports) {
"use strict";
module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next)yield walker.value;
    };
};

});


$parcel$export(module.exports, "countLines", () => $fddc9169ba2fd655$export$2e2bcd8739ae039);
$parcel$export(module.exports, "generateBuildMetrics", () => $15d4bc8b6fca8c7e$export$2e2bcd8739ae039);
$parcel$export(module.exports, "generateCertificate", () => $c6cbdbdbaf0fafc1$export$2e2bcd8739ae039);
$parcel$export(module.exports, "getCertificate", () => $186980c178984fd2$export$2e2bcd8739ae039);
$parcel$export(module.exports, "getModuleParts", () => $313980afb666b13e$export$2e2bcd8739ae039);
$parcel$export(module.exports, "getRootDir", () => $275c1a71c92a4142$export$2e2bcd8739ae039);
$parcel$export(module.exports, "isDirectoryInside", () => $ea105385370dfccd$export$2e2bcd8739ae039);
$parcel$export(module.exports, "isURL", () => $f7d48e99e9c9e3b2$export$2e2bcd8739ae039);
$parcel$export(module.exports, "objectHash", () => $295998acc3b31ee9$export$2e2bcd8739ae039);
$parcel$export(module.exports, "prettifyTime", () => $ec068ba9e84f8eea$export$2e2bcd8739ae039);
$parcel$export(module.exports, "prettyDiagnostic", () => $f02d6a9d30f55938$export$2e2bcd8739ae039);
$parcel$export(module.exports, "PromiseQueue", () => $b0fd219fea43bcac$export$2e2bcd8739ae039);
$parcel$export(module.exports, "validateSchema", () => $4ca1027d34905147$export$2e2bcd8739ae039);
$parcel$export(module.exports, "TapStream", () => $3f2d35ad38f40faa$export$2e2bcd8739ae039);
$parcel$export(module.exports, "urlJoin", () => $dfabc3743c08d51c$export$2e2bcd8739ae039);
$parcel$export(module.exports, "relativeUrl", () => $b18990c6c3ea36b3$export$2e2bcd8739ae039);
$parcel$export(module.exports, "createDependencyLocation", () => $43b0dce5dd282650$export$2e2bcd8739ae039);
$parcel$export(module.exports, "debounce", () => $1ba22b2a95920d8e$export$2e2bcd8739ae039);
$parcel$export(module.exports, "throttle", () => $e499d3e618e93ebd$export$2e2bcd8739ae039);
$parcel$export(module.exports, "openInBrowser", () => $f064b622a304e96c$export$2e2bcd8739ae039);
$parcel$export(module.exports, "findAlternativeNodeModules", () => $6aebdac47db0459e$export$6643be4f4e63e994);
$parcel$export(module.exports, "findAlternativeFiles", () => $6aebdac47db0459e$export$4eeb1b3271a29661);
$parcel$export(module.exports, "blobToBuffer", () => $a3de5fd908122828$export$e234f0a8b913b7b9);
$parcel$export(module.exports, "blobToString", () => $a3de5fd908122828$export$c6adc95df13c8b9e);
$parcel$export(module.exports, "unique", () => $9631335a11debdd4$export$7a5d5c156e7dc406);
$parcel$export(module.exports, "objectSortedEntries", () => $9631335a11debdd4$export$61559eb31990eff6);
$parcel$export(module.exports, "objectSortedEntriesDeep", () => $9631335a11debdd4$export$1a9b883158ac407c);
$parcel$export(module.exports, "setDifference", () => $9631335a11debdd4$export$8bd517cc5b3722f7);
$parcel$export(module.exports, "setEqual", () => $9631335a11debdd4$export$dd7d5a65a6b6780f);
$parcel$export(module.exports, "setIntersect", () => $9631335a11debdd4$export$9404cfefeb010e68);
$parcel$export(module.exports, "setUnion", () => $9631335a11debdd4$export$667066422fa0af46);
$parcel$export(module.exports, "resolveConfig", () => $10671d0be444e08b$export$7eca4ea16d4c8343);
$parcel$export(module.exports, "resolveConfigSync", () => $10671d0be444e08b$export$d175e66e9fcd7b75);
$parcel$export(module.exports, "loadConfig", () => $10671d0be444e08b$export$c1a4367d4847eb06);
$parcel$export(module.exports, "DefaultMap", () => $5783bf7916ff59db$export$674cd7dcb504ac5c);
$parcel$export(module.exports, "DefaultWeakMap", () => $5783bf7916ff59db$export$4924f7ffab2ae440);
$parcel$export(module.exports, "makeDeferredWithPromise", () => $75952a43539cb60f$export$93f345b3f0dd27e7);
$parcel$export(module.exports, "getProgressMessage", () => $01f892dcf45b57a7$export$d28945a2f2ba5e30);
$parcel$export(module.exports, "isGlob", () => $e8d0e504a4244d84$export$f3a2344a73dbdd42);
$parcel$export(module.exports, "isGlobMatch", () => $e8d0e504a4244d84$export$16e6d319a883f04e);
$parcel$export(module.exports, "globSync", () => $e8d0e504a4244d84$export$42275ba87174c828);
$parcel$export(module.exports, "glob", () => $e8d0e504a4244d84$export$442f1a04865e4790);
$parcel$export(module.exports, "globToRegex", () => $e8d0e504a4244d84$export$c0436a5422df81e4);
$parcel$export(module.exports, "hashStream", () => $4b14026b40817fca$export$8a9ede1a78d6a1fe);
$parcel$export(module.exports, "hashObject", () => $4b14026b40817fca$export$3477f9615e12f61d);
$parcel$export(module.exports, "hashFile", () => $4b14026b40817fca$export$42462553d605d8cd);
$parcel$export(module.exports, "SharedBuffer", () => $1c93db5abaa33eaa$export$8b1c306fed4227bf);
$parcel$export(module.exports, "fuzzySearch", () => $4ca1027d34905147$export$2115c2c0a84eef61);
$parcel$export(module.exports, "createHTTPServer", () => $0e887a49fdd81cad$export$3b1983e9896f988b);
$parcel$export(module.exports, "normalizePath", () => $3dff16cfd200ff25$export$6af368f973c74c5);
$parcel$export(module.exports, "normalizeSeparators", () => $3dff16cfd200ff25$export$16778b798ae8e49d);
$parcel$export(module.exports, "relativePath", () => $3dff16cfd200ff25$export$7413eea5ad243d4);
$parcel$export(module.exports, "replaceURLReferences", () => $bc66accb63b05e9a$export$d0d0105f44defc19);
$parcel$export(module.exports, "replaceInlineReferences", () => $bc66accb63b05e9a$export$f074a8f9bef628fd);
$parcel$export(module.exports, "measureStreamLength", () => $29bb96d8a6524ff0$export$457f03b1bf37ec1a);
$parcel$export(module.exports, "readableFromStringOrBuffer", () => $29bb96d8a6524ff0$export$dc30d0b81ccad9c7);
$parcel$export(module.exports, "bufferStream", () => $29bb96d8a6524ff0$export$f109d1c79a5ae5a1);
$parcel$export(module.exports, "blobToStream", () => $29bb96d8a6524ff0$export$5ba0b0e7e2e9ae7a);
$parcel$export(module.exports, "streamFromPromise", () => $29bb96d8a6524ff0$export$7ebca75e1135fcd6);
$parcel$export(module.exports, "fallbackStream", () => $29bb96d8a6524ff0$export$68f6769cfac79897);
$parcel$export(module.exports, "relativeBundlePath", () => $76ed5e95485fb544$export$402b5a120b1183b3);
$parcel$export(module.exports, "ansiHtml", () => $7ea2b0152b726098$export$565d0ff71645da31);
$parcel$export(module.exports, "escapeHTML", () => $557d7b477cbdc368$export$5dd27816c66fb702);
$parcel$export(module.exports, "SOURCEMAP_RE", () => $46fc74961fdcfe31$export$db8833b274702782);
$parcel$export(module.exports, "SOURCEMAP_EXTENSIONS", () => $46fc74961fdcfe31$export$4b206fdd01e58041);
$parcel$export(module.exports, "matchSourceMappingURL", () => $46fc74961fdcfe31$export$ff36203a2e5cc203);
$parcel$export(module.exports, "loadSourceMapUrl", () => $46fc74961fdcfe31$export$527a92fa675f5e93);
$parcel$export(module.exports, "loadSourceMap", () => $46fc74961fdcfe31$export$c500fecaca54de65);
$parcel$export(module.exports, "remapSourceLocation", () => $46fc74961fdcfe31$export$2fed780245c466c1);
function $fddc9169ba2fd655$export$2e2bcd8739ae039(string, startIndex = 0) {
    let lines = 1;
    for(let i = startIndex; i < string.length; i++)if (string.charAt(i) === "\n") lines++;
    return lines;
}



var $812806c6461f2963$exports = {};
"use strict";
function $812806c6461f2963$var$nullthrows(x, message) {
    if (x != null) return x;
    var error = new Error(message !== undefined ? message : "Got unexpected " + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
}
$812806c6461f2963$exports = $812806c6461f2963$var$nullthrows;
$812806c6461f2963$exports.default = $812806c6461f2963$var$nullthrows;
Object.defineProperty($812806c6461f2963$exports, "__esModule", {
    value: true
});




async function $15d4bc8b6fca8c7e$var$getSourcemapSizes(filePath, fs, projectRoot) {
    let bundleContents = await fs.readFile(filePath, "utf-8");
    let mapUrlData = await (0, $46fc74961fdcfe31$export$527a92fa675f5e93)(fs, filePath, bundleContents);
    if (!mapUrlData) return null;
    let rawMap = mapUrlData.map;
    let sourceMap = new (0, ($parcel$interopDefault($8C1kk$parcelsourcemap)))(projectRoot);
    sourceMap.addVLQMap(rawMap);
    let parsedMapData = sourceMap.getMap();
    if (parsedMapData.mappings.length > 2) {
        let sources = parsedMapData.sources.map((s)=>(0, ($parcel$interopDefault($8C1kk$path))).normalize((0, ($parcel$interopDefault($8C1kk$path))).join(projectRoot, s)));
        let currLine = 1;
        let currColumn = 0;
        let currMappingIndex = 0;
        let currMapping = parsedMapData.mappings[currMappingIndex];
        let nextMapping = parsedMapData.mappings[currMappingIndex + 1];
        let sourceSizes = new Array(sources.length).fill(0);
        let unknownOrigin = 0;
        for(let i = 0; i < bundleContents.length; i++){
            let character = bundleContents[i];
            while(nextMapping && nextMapping.generated.line === currLine && nextMapping.generated.column <= currColumn){
                currMappingIndex++;
                currMapping = parsedMapData.mappings[currMappingIndex];
                nextMapping = parsedMapData.mappings[currMappingIndex + 1];
            }
            let currentSource = currMapping.source;
            let charSize = Buffer.byteLength(character, "utf8");
            if (currentSource != null && currMapping.generated.line === currLine && currMapping.generated.column <= currColumn) sourceSizes[currentSource] += charSize;
            else unknownOrigin += charSize;
            if (character === "\n") {
                currColumn = 0;
                currLine++;
            } else currColumn++;
        }
        let sizeMap = new Map();
        for(let i1 = 0; i1 < sourceSizes.length; i1++)sizeMap.set(sources[i1], sourceSizes[i1]);
        sizeMap.set("", unknownOrigin);
        return sizeMap;
    }
}
async function $15d4bc8b6fca8c7e$var$createBundleStats(bundle, fs, projectRoot) {
    let filePath = bundle.filePath;
    let sourcemapSizes = await $15d4bc8b6fca8c7e$var$getSourcemapSizes(filePath, fs, projectRoot);
    let assets = new Map();
    bundle.traverseAssets((asset)=>{
        let filePath = (0, ($parcel$interopDefault($8C1kk$path))).normalize(asset.filePath);
        assets.set(filePath, {
            filePath: filePath,
            size: asset.stats.size,
            originalSize: asset.stats.size,
            time: asset.stats.time
        });
    });
    let assetsReport = [];
    if (sourcemapSizes && sourcemapSizes.size) assetsReport = Array.from(sourcemapSizes.keys()).map((filePath)=>{
        let foundSize = sourcemapSizes.get(filePath) || 0;
        let stats = assets.get(filePath) || {
            filePath: filePath,
            size: foundSize,
            originalSize: foundSize,
            time: 0
        };
        return {
            ...stats,
            size: foundSize
        };
    });
    else assetsReport = Array.from(assets.values());
    return {
        filePath: (0, (/*@__PURE__*/$parcel$interopDefault($812806c6461f2963$exports)))(bundle.filePath),
        size: bundle.stats.size,
        time: bundle.stats.time,
        assets: assetsReport.sort((a, b)=>b.size - a.size)
    };
}
async function $15d4bc8b6fca8c7e$export$2e2bcd8739ae039(bundles, fs, projectRoot) {
    bundles.sort((a, b)=>b.stats.size - a.stats.size).filter((b)=>!!b.filePath);
    return {
        bundles: (await Promise.all(bundles.map((b)=>$15d4bc8b6fca8c7e$var$createBundleStats(b, fs, projectRoot)))).filter((e)=>!!e)
    };
}


var $99e85628b30fe009$exports = {};
/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */ 
$99e85628b30fe009$exports = (parcelRequire("iGlOy"));
var $ca9d5cba0afae339$exports = {};
/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */ 
var $iGlOy = parcelRequire("iGlOy");
var $871289bd32ea5f15$exports = {};
/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */ 
var $iGlOy = parcelRequire("iGlOy");
var $4143f576ffbec226$exports = {};
/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */ 
var $iGlOy = parcelRequire("iGlOy");
var $53abc20733f4b0dc$exports = {};
/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */ var $53abc20733f4b0dc$var$api = {};
$53abc20733f4b0dc$exports = $53abc20733f4b0dc$var$api;
// baseN alphabet indexes
var $53abc20733f4b0dc$var$_reverseAlphabets = {};
/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */ $53abc20733f4b0dc$var$api.encode = function(input, alphabet, maxline) {
    if (typeof alphabet !== "string") throw new TypeError('"alphabet" must be a string.');
    if (maxline !== undefined && typeof maxline !== "number") throw new TypeError('"maxline" must be a number.');
    var output = "";
    if (!(input instanceof Uint8Array)) // assume forge byte buffer
    output = $53abc20733f4b0dc$var$_encodeWithByteBuffer(input, alphabet);
    else {
        var i = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [
            0
        ];
        for(i = 0; i < input.length; ++i){
            for(var j = 0, carry = input[i]; j < digits.length; ++j){
                carry += digits[j] << 8;
                digits[j] = carry % base;
                carry = carry / base | 0;
            }
            while(carry > 0){
                digits.push(carry % base);
                carry = carry / base | 0;
            }
        }
        // deal with leading zeros
        for(i = 0; input[i] === 0 && i < input.length - 1; ++i)output += first;
        // convert digits to a string
        for(i = digits.length - 1; i >= 0; --i)output += alphabet[digits[i]];
    }
    if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
    }
    return output;
};
/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */ $53abc20733f4b0dc$var$api.decode = function(input, alphabet) {
    if (typeof input !== "string") throw new TypeError('"input" must be a string.');
    if (typeof alphabet !== "string") throw new TypeError('"alphabet" must be a string.');
    var table = $53abc20733f4b0dc$var$_reverseAlphabets[alphabet];
    if (!table) {
        // compute reverse alphabet
        table = $53abc20733f4b0dc$var$_reverseAlphabets[alphabet] = [];
        for(var i = 0; i < alphabet.length; ++i)table[alphabet.charCodeAt(i)] = i;
    }
    // remove whitespace characters
    input = input.replace(/\s/g, "");
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var bytes = [
        0
    ];
    for(var i = 0; i < input.length; i++){
        var value = table[input.charCodeAt(i)];
        if (value === undefined) return;
        for(var j = 0, carry = value; j < bytes.length; ++j){
            carry += bytes[j] * base;
            bytes[j] = carry & 0xff;
            carry >>= 8;
        }
        while(carry > 0){
            bytes.push(carry & 0xff);
            carry >>= 8;
        }
    }
    // deal with leading zeros
    for(var k = 0; input[k] === first && k < input.length - 1; ++k)bytes.push(0);
    if (typeof Buffer !== "undefined") return Buffer.from(bytes.reverse());
    return new Uint8Array(bytes.reverse());
};
function $53abc20733f4b0dc$var$_encodeWithByteBuffer(input, alphabet) {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [
        0
    ];
    for(i = 0; i < input.length(); ++i){
        for(var j = 0, carry = input.at(i); j < digits.length; ++j){
            carry += digits[j] << 8;
            digits[j] = carry % base;
            carry = carry / base | 0;
        }
        while(carry > 0){
            digits.push(carry % base);
            carry = carry / base | 0;
        }
    }
    var output = "";
    // deal with leading zeros
    for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i)output += first;
    // convert digits to a string
    for(i = digits.length - 1; i >= 0; --i)output += alphabet[digits[i]];
    return output;
}


/* Utilities API */ var $4143f576ffbec226$var$util = $4143f576ffbec226$exports = $iGlOy.util = $iGlOy.util || {};
// define setImmediate and nextTick
(function() {
    // use native nextTick (unless we're in webpack)
    // webpack (or better node-libs-browser polyfill) sets process.browser.
    // this way we can detect webpack properly
    if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        $4143f576ffbec226$var$util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") $4143f576ffbec226$var$util.setImmediate = setImmediate;
        else // polyfill setImmediate with nextTick, older versions of node
        // (those w/o setImmediate) won't totally starve IO
        $4143f576ffbec226$var$util.setImmediate = $4143f576ffbec226$var$util.nextTick;
        return;
    }
    // polyfill nextTick with native setImmediate
    if (typeof setImmediate === "function") {
        $4143f576ffbec226$var$util.setImmediate = function() {
            return setImmediate.apply(undefined, arguments);
        };
        $4143f576ffbec226$var$util.nextTick = function(callback) {
            return setImmediate(callback);
        };
        return;
    }
    /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */ // polyfill with setTimeout
    $4143f576ffbec226$var$util.setImmediate = function(callback) {
        setTimeout(callback, 0);
    };
    // upgrade polyfill to use postMessage
    if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        var msg = "forge.setImmediate";
        var callbacks = [];
        $4143f576ffbec226$var$util.setImmediate = function(callback) {
            callbacks.push(callback);
            // only send message when one hasn't been sent in
            // the current turn of the event loop
            if (callbacks.length === 1) window.postMessage(msg, "*");
        };
        function handler(event) {
            if (event.source === window && event.data === msg) {
                event.stopPropagation();
                var copy = callbacks.slice();
                callbacks.length = 0;
                copy.forEach(function(callback) {
                    callback();
                });
            }
        }
        window.addEventListener("message", handler, true);
    }
    // upgrade polyfill to use MutationObserver
    if (typeof MutationObserver !== "undefined") {
        // polyfill with MutationObserver
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
                callback();
            });
        }).observe(div, {
            attributes: true
        });
        var oldSetImmediate = $4143f576ffbec226$var$util.setImmediate;
        $4143f576ffbec226$var$util.setImmediate = function(callback) {
            if (Date.now() - now > 15) {
                now = Date.now();
                oldSetImmediate(callback);
            } else {
                callbacks.push(callback);
                // only trigger observer when it hasn't been triggered in
                // the current turn of the event loop
                if (callbacks.length === 1) div.setAttribute("a", attr = !attr);
            }
        };
    }
    $4143f576ffbec226$var$util.nextTick = $4143f576ffbec226$var$util.setImmediate;
})();
// check if running under Node.js
$4143f576ffbec226$var$util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.
$4143f576ffbec226$var$util.globalScope = function() {
    if ($4143f576ffbec226$var$util.isNodejs) return $parcel$global;
    return typeof self === "undefined" ? window : self;
}();
// define isArray
$4143f576ffbec226$var$util.isArray = Array.isArray || function(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
};
// define isArrayBuffer
$4143f576ffbec226$var$util.isArrayBuffer = function(x) {
    return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
};
// define isArrayBufferView
$4143f576ffbec226$var$util.isArrayBufferView = function(x) {
    return x && $4143f576ffbec226$var$util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};
/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */ function $4143f576ffbec226$var$_checkBitsParam(n) {
    if (!(n === 8 || n === 16 || n === 24 || n === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
}
// TODO: set ByteBuffer to best available backing
$4143f576ffbec226$var$util.ByteBuffer = $4143f576ffbec226$var$ByteStringBuffer;
/** Buffer w/BinaryString backing */ /**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */ function $4143f576ffbec226$var$ByteStringBuffer(b) {
    // TODO: update to match DataBuffer API
    // the data in this buffer
    this.data = "";
    // the pointer for reading from this buffer
    this.read = 0;
    if (typeof b === "string") this.data = b;
    else if ($4143f576ffbec226$var$util.isArrayBuffer(b) || $4143f576ffbec226$var$util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) this.data = b.toString("binary");
        else {
            // convert native buffer to forge buffer
            // FIXME: support native buffers internally instead
            var arr = new Uint8Array(b);
            try {
                this.data = String.fromCharCode.apply(null, arr);
            } catch (e) {
                for(var i = 0; i < arr.length; ++i)this.putByte(arr[i]);
            }
        }
    } else if (b instanceof $4143f576ffbec226$var$ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        // copy existing buffer
        this.data = b.data;
        this.read = b.read;
    }
    // used for v8 optimization
    this._constructedStringLength = 0;
}
$4143f576ffbec226$var$util.ByteStringBuffer = $4143f576ffbec226$var$ByteStringBuffer;
/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */ var $4143f576ffbec226$var$_MAX_CONSTRUCTED_STRING_LENGTH = 4096;
$4143f576ffbec226$var$util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
    this._constructedStringLength += x;
    if (this._constructedStringLength > $4143f576ffbec226$var$_MAX_CONSTRUCTED_STRING_LENGTH) {
        // this substr() should cause the constructed string to join
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
    }
};
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putByte = function(b) {
    return this.putBytes(String.fromCharCode(b));
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
    b = String.fromCharCode(b);
    var d = this.data;
    while(n > 0){
        if (n & 1) d += b;
        n >>>= 1;
        if (n > 0) b += b;
    }
    this.data = d;
    this._optimizeConstructedString(n);
    return this;
};
/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a binary encoded string) to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putBytes = function(bytes) {
    this.data += bytes;
    this._optimizeConstructedString(bytes.length);
    return this;
};
/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putString = function(str) {
    return this.putBytes($4143f576ffbec226$var$util.encodeUtf8(str));
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt16 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt24 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt32 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt16Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt24Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt32Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putInt = function(i, n) {
    $4143f576ffbec226$var$_checkBitsParam(n);
    var bytes = "";
    do {
        n -= 8;
        bytes += String.fromCharCode(i >> n & 0xFF);
    }while (n > 0);
    return this.putBytes(bytes);
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
    // putInt checks n
    if (i < 0) i += 2 << n - 1;
    return this.putInt(i, n);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
    return this.putBytes(buffer.getBytes());
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt16 = function() {
    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    this.read += 2;
    return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt24 = function() {
    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    this.read += 3;
    return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt32 = function() {
    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    this.read += 4;
    return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt16Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    this.read += 2;
    return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt24Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    this.read += 3;
    return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt32Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    this.read += 4;
    return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getInt = function(n) {
    $4143f576ffbec226$var$_checkBitsParam(n);
    var rval = 0;
    do {
        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
    }while (n > 0);
    return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getSignedInt = function(n) {
    // getInt checks n
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) x -= max << 1;
    return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer. Note that the resulting string is binary encoded (in node.js this
 * encoding is referred to as `binary`, it is *not* `utf8`).
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
        // read count bytes
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
    } else if (count === 0) rval = "";
    else {
        // read all bytes, optimize to only copy when needed
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
    }
    return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.at = function(i) {
    return this.data.charCodeAt(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.setAt = function(i, b) {
    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
    return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.copy = function() {
    var c = $4143f576ffbec226$var$util.createBuffer(this.data);
    c.read = this.read;
    return c;
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.compact = function() {
    if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
    }
    return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.clear = function() {
    this.data = "";
    this.read = 0;
    return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.truncate = function(count) {
    var len = Math.max(0, this.length() - count);
    this.data = this.data.substr(this.read, len);
    this.read = 0;
    return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.toHex = function() {
    var rval = "";
    for(var i = this.read; i < this.data.length; ++i){
        var b = this.data.charCodeAt(i);
        if (b < 16) rval += "0";
        rval += b.toString(16);
    }
    return rval;
};
/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */ $4143f576ffbec226$var$util.ByteStringBuffer.prototype.toString = function() {
    return $4143f576ffbec226$var$util.decodeUtf8(this.bytes());
};
/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */ function $4143f576ffbec226$var$DataBuffer(b, options) {
    // default options
    options = options || {};
    // pointers for read from/write to buffer
    this.read = options.readOffset || 0;
    this.growSize = options.growSize || 1024;
    var isArrayBuffer = $4143f576ffbec226$var$util.isArrayBuffer(b);
    var isArrayBufferView = $4143f576ffbec226$var$util.isArrayBufferView(b);
    if (isArrayBuffer || isArrayBufferView) {
        // use ArrayBuffer directly
        if (isArrayBuffer) this.data = new DataView(b);
        else // TODO: adjust read/write offset based on the type of view
        // or specify that this must be done in the options ... that the
        // offsets are byte-based
        this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
    }
    // initialize to empty array buffer and add any given bytes using putBytes
    this.data = new DataView(new ArrayBuffer(0));
    this.write = 0;
    if (b !== null && b !== undefined) this.putBytes(b);
    if ("writeOffset" in options) this.write = options.writeOffset;
}
$4143f576ffbec226$var$util.DataBuffer = $4143f576ffbec226$var$DataBuffer;
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.length = function() {
    return this.write - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
};
/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.accommodate = function(amount, growSize) {
    if (this.length() >= amount) return this;
    growSize = Math.max(growSize || this.growSize, amount);
    // grow buffer
    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
    var dst = new Uint8Array(this.length() + growSize);
    dst.set(src);
    this.data = new DataView(dst.buffer);
    return this;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putByte = function(b) {
    this.accommodate(1);
    this.data.setUint8(this.write++, b);
    return this;
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.fillWithByte = function(b, n) {
    this.accommodate(n);
    for(var i = 0; i < n; ++i)this.data.setUint8(b);
    return this;
};
/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
    if ($4143f576ffbec226$var$util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
    }
    if ($4143f576ffbec226$var$util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
    }
    // bytes is a util.DataBuffer or equivalent
    if (bytes instanceof $4143f576ffbec226$var$util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && $4143f576ffbec226$var$util.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
    }
    if (bytes instanceof $4143f576ffbec226$var$util.ByteStringBuffer) {
        // copy binary string and process as the same as a string parameter below
        bytes = bytes.data;
        encoding = "binary";
    }
    // string conversion
    encoding = encoding || "binary";
    if (typeof bytes === "string") {
        var view;
        // decode from string
        if (encoding === "hex") {
            this.accommodate(Math.ceil(bytes.length / 2));
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += $4143f576ffbec226$var$util.binary.hex.decode(bytes, view, this.write);
            return this;
        }
        if (encoding === "base64") {
            this.accommodate(Math.ceil(bytes.length / 4) * 3);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += $4143f576ffbec226$var$util.binary.base64.decode(bytes, view, this.write);
            return this;
        }
        // encode text as UTF-8 bytes
        if (encoding === "utf8") {
            // encode as UTF-8 then decode string as raw binary
            bytes = $4143f576ffbec226$var$util.encodeUtf8(bytes);
            encoding = "binary";
        }
        // decode string as raw binary
        if (encoding === "binary" || encoding === "raw") {
            // one byte per character
            this.accommodate(bytes.length);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += $4143f576ffbec226$var$util.binary.raw.decode(view);
            return this;
        }
        // encode text as UTF-16 bytes
        if (encoding === "utf16") {
            // two bytes per character
            this.accommodate(bytes.length * 2);
            view = new Uint16Array(this.data.buffer, this.write);
            this.write += $4143f576ffbec226$var$util.text.utf16.encode(view);
            return this;
        }
        throw new Error("Invalid encoding: " + encoding);
    }
    throw Error("Invalid parameter: " + bytes);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putBuffer = function(buffer) {
    this.putBytes(buffer);
    buffer.clear();
    return this;
};
/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putString = function(str) {
    return this.putBytes(str, "utf16");
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt16 = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i);
    this.write += 2;
    return this;
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt24 = function(i) {
    this.accommodate(3);
    this.data.setInt16(this.write, i >> 8 & 0xFFFF);
    this.data.setInt8(this.write, i >> 16 & 0xFF);
    this.write += 3;
    return this;
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt32 = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i);
    this.write += 4;
    return this;
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt16Le = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i, true);
    this.write += 2;
    return this;
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt24Le = function(i) {
    this.accommodate(3);
    this.data.setInt8(this.write, i >> 16 & 0xFF);
    this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
    this.write += 3;
    return this;
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt32Le = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i, true);
    this.write += 4;
    return this;
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putInt = function(i, n) {
    $4143f576ffbec226$var$_checkBitsParam(n);
    this.accommodate(n / 8);
    do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 0xFF);
    }while (n > 0);
    return this;
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.putSignedInt = function(i, n) {
    $4143f576ffbec226$var$_checkBitsParam(n);
    this.accommodate(n / 8);
    if (i < 0) i += 2 << n - 1;
    return this.putInt(i, n);
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt16 = function() {
    var rval = this.data.getInt16(this.read);
    this.read += 2;
    return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt24 = function() {
    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    this.read += 3;
    return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt32 = function() {
    var rval = this.data.getInt32(this.read);
    this.read += 4;
    return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt16Le = function() {
    var rval = this.data.getInt16(this.read, true);
    this.read += 2;
    return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt24Le = function() {
    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
    this.read += 3;
    return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt32Le = function() {
    var rval = this.data.getInt32(this.read, true);
    this.read += 4;
    return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getInt = function(n) {
    $4143f576ffbec226$var$_checkBitsParam(n);
    var rval = 0;
    do {
        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
    }while (n > 0);
    return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getSignedInt = function(n) {
    // getInt checks n
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) x -= max << 1;
    return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.getBytes = function(count) {
    // TODO: deprecate this method, it is poorly named and
    // this.toString('binary') replaces it
    // add a toTypedArray()/toArrayBuffer() function
    var rval;
    if (count) {
        // read count bytes
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
    } else if (count === 0) rval = "";
    else {
        // read all bytes, optimize to only copy when needed
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
    }
    return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.bytes = function(count) {
    // TODO: deprecate this method, it is poorly named, add "getString()"
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.at = function(i) {
    return this.data.getUint8(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.setAt = function(i, b) {
    this.data.setUint8(i, b);
    return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.copy = function() {
    return new $4143f576ffbec226$var$util.DataBuffer(this);
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
    }
    return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.clear = function() {
    this.data = new DataView(new ArrayBuffer(0));
    this.read = this.write = 0;
    return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.truncate = function(count) {
    this.write = Math.max(0, this.length() - count);
    this.read = Math.min(this.read, this.write);
    return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.toHex = function() {
    var rval = "";
    for(var i = this.read; i < this.data.byteLength; ++i){
        var b = this.data.getUint8(i);
        if (b < 16) rval += "0";
        rval += b.toString(16);
    }
    return rval;
};
/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */ $4143f576ffbec226$var$util.DataBuffer.prototype.toString = function(encoding) {
    var view = new Uint8Array(this.data, this.read, this.length());
    encoding = encoding || "utf8";
    // encode to string
    if (encoding === "binary" || encoding === "raw") return $4143f576ffbec226$var$util.binary.raw.encode(view);
    if (encoding === "hex") return $4143f576ffbec226$var$util.binary.hex.encode(view);
    if (encoding === "base64") return $4143f576ffbec226$var$util.binary.base64.encode(view);
    // decode to text
    if (encoding === "utf8") return $4143f576ffbec226$var$util.text.utf8.decode(view);
    if (encoding === "utf16") return $4143f576ffbec226$var$util.text.utf16.decode(view);
    throw new Error("Invalid encoding: " + encoding);
};
/** End Buffer w/UInt8Array backing */ /**
 * Creates a buffer that stores bytes. A value may be given to populate the
 * buffer with data. This value can either be string of encoded bytes or a
 * regular string of characters. When passing a string of binary encoded
 * bytes, the encoding `raw` should be given. This is also the default. When
 * passing a string of characters, the encoding `utf8` should be given.
 *
 * @param [input] a string with encoded bytes to store in the buffer.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */ $4143f576ffbec226$var$util.createBuffer = function(input, encoding) {
    // TODO: deprecate, use new ByteBuffer() instead
    encoding = encoding || "raw";
    if (input !== undefined && encoding === "utf8") input = $4143f576ffbec226$var$util.encodeUtf8(input);
    return new $4143f576ffbec226$var$util.ByteBuffer(input);
};
/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */ $4143f576ffbec226$var$util.fillString = function(c, n) {
    var s = "";
    while(n > 0){
        if (n & 1) s += c;
        n >>>= 1;
        if (n > 0) c += c;
    }
    return s;
};
/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */ $4143f576ffbec226$var$util.xorBytes = function(s1, s2, n) {
    var s3 = "";
    var b = "";
    var t = "";
    var i = 0;
    var c = 0;
    for(; n > 0; --n, ++i){
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
            s3 += t;
            t = "";
            c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
    }
    s3 += t;
    return s3;
};
/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */ $4143f576ffbec226$var$util.hexToBytes = function(hex) {
    // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
    var rval = "";
    var i = 0;
    if (hex.length & true) {
        // odd number of characters, convert first character alone
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
    }
    // convert 2 characters (1 byte) at a time
    for(; i < hex.length; i += 2)rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return rval;
};
/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */ $4143f576ffbec226$var$util.bytesToHex = function(bytes) {
    // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
    return $4143f576ffbec226$var$util.createBuffer(bytes).toHex();
};
/**
 * Converts an 32-bit integer to 