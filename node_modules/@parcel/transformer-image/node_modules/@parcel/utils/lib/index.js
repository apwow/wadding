var $8C1kk$path = require("path");
var $8C1kk$stream = require("stream");
var $8C1kk$parcelsourcemap = require("@parcel/source-map");
var $8C1kk$parcellogger = require("@parcel/logger");
var $8C1kk$crypto = require("crypto");
var $8C1kk$os = require("os");
var $8C1kk$util = require("util");
var $8C1kk$fs = require("fs");
var $8C1kk$events = require("events");
var $8C1kk$parcelcodeframe = require("@parcel/codeframe");
var $8C1kk$parcelmarkdownansi = require("@parcel/markdown-ansi");
var $8C1kk$chalk = require("chalk");
var $8C1kk$tty = require("tty");
var $8C1kk$assert = require("assert");
var $8C1kk$parceldiagnostic = require("@parcel/diagnostic");
var $8C1kk$url = require("url");
var $8C1kk$child_process = require("child_process");
var $8C1kk$buffer = require("buffer");
var $8C1kk$parcelhash = require("@parcel/hash");
var $8C1kk$http = require("http");
var $8C1kk$https = require("https");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire0b48"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire0b48"] = parcelRequire;
}
parcelRequire.register("iGlOy", function(module, exports) {
/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */ module.exports = {
    // default options
    options: {
        usePureJavaScript: false
    }
};

});

parcelRequire.register("ai0Z9", function(module, exports) {
/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */ 
var $iGlOy = parcelRequire("iGlOy");
module.exports = $iGlOy.md = $iGlOy.md || {};
$iGlOy.md.algorithms = $iGlOy.md.algorithms || {};

});

parcelRequire.register("4997P", function(module, exports) {
"use strict";


var $2zM8v = parcelRequire("2zM8v");

var $lKEF0 = parcelRequire("lKEF0");

var $5MQDC = parcelRequire("5MQDC");

var $7XmS6 = parcelRequire("7XmS6");
const $304f14c7e435813f$var$isObject = (val)=>val && typeof val === "object" && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */ const $304f14c7e435813f$var$picomatch = (glob, options, returnState = false)=>{
    if (Array.isArray(glob)) {
        const fns = glob.map((input)=>$304f14c7e435813f$var$picomatch(input, options, returnState));
        const arrayMatcher = (str)=>{
            for (const isMatch of fns){
                const state = isMatch(str);
                if (state) return state;
            }
            return false;
        };
        return arrayMatcher;
    }
    const isState = $304f14c7e435813f$var$isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) throw new TypeError("Expected pattern to be a non-empty string");
    const opts = options || {};
    const posix = $5MQDC.isWindows(options);
    const regex = isState ? $304f14c7e435813f$var$picomatch.compileRe(glob, options) : $304f14c7e435813f$var$picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = ()=>false;
    if (opts.ignore) {
        const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null
        };
        isIgnored = $304f14c7e435813f$var$picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false)=>{
        const { isMatch: isMatch , match: match , output: output  } = $304f14c7e435813f$var$picomatch.test(input, regex, options, {
            glob: glob,
            posix: posix
        });
        const result = {
            glob: glob,
            state: state,
            regex: regex,
            posix: posix,
            input: input,
            output: output,
            match: match,
            isMatch: isMatch
        };
        if (typeof opts.onResult === "function") opts.onResult(result);
        if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") opts.onIgnore(result);
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") opts.onMatch(result);
        return returnObject ? result : true;
    };
    if (returnState) matcher.state = state;
    return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */ $304f14c7e435813f$var$picomatch.test = (input, regex, options, { glob: glob , posix: posix  } = {})=>{
    if (typeof input !== "string") throw new TypeError("Expected input to be a string");
    if (input === "") return {
        isMatch: false,
        output: ""
    };
    const opts = options || {};
    const format = opts.format || (posix ? $5MQDC.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
    }
    if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) match = $304f14c7e435813f$var$picomatch.matchBase(input, regex, options, posix);
        else match = regex.exec(output);
    }
    return {
        isMatch: Boolean(match),
        match: match,
        output: output
    };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */ $304f14c7e435813f$var$picomatch.matchBase = (input, glob, options, posix = $5MQDC.isWindows(options))=>{
    const regex = glob instanceof RegExp ? glob : $304f14c7e435813f$var$picomatch.makeRe(glob, options);
    return regex.test($8C1kk$path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ $304f14c7e435813f$var$picomatch.isMatch = (str, patterns, options)=>$304f14c7e435813f$var$picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */ $304f14c7e435813f$var$picomatch.parse = (pattern, options)=>{
    if (Array.isArray(pattern)) return pattern.map((p)=>$304f14c7e435813f$var$picomatch.parse(p, options));
    return $lKEF0(pattern, {
        ...options,
        fastpaths: false
    });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ $304f14c7e435813f$var$picomatch.scan = (input, options)=>$2zM8v(input, options);
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */ $304f14c7e435813f$var$picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
    if (returnOutput === true) return state.output;
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) source = `^(?!${source}).*$`;
    const regex = $304f14c7e435813f$var$picomatch.toRegex(source, options);
    if (returnState === true) regex.state = state;
    return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ $304f14c7e435813f$var$picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
    if (!input || typeof input !== "string") throw new TypeError("Expected a non-empty string");
    let parsed = {
        negated: false,
        fastpaths: true
    };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) parsed.output = $lKEF0.fastpaths(input, options);
    if (!parsed.output) parsed = $lKEF0(input, options);
    return $304f14c7e435813f$var$picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */ $304f14c7e435813f$var$picomatch.toRegex = (source, options)=>{
    try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
    }
};
/**
 * Picomatch constants.
 * @return {Object}
 */ $304f14c7e435813f$var$picomatch.constants = $7XmS6;
/**
 * Expose "picomatch"
 */ module.exports = $304f14c7e435813f$var$picomatch;

});
parcelRequire.register("2zM8v", function(module, exports) {
"use strict";

var $5MQDC = parcelRequire("5MQDC");

var $7XmS6 = parcelRequire("7XmS6");
var $1e0430853cfb927a$require$CHAR_ASTERISK = $7XmS6.CHAR_ASTERISK;
var $1e0430853cfb927a$require$CHAR_AT = $7XmS6.CHAR_AT;
var $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH = $7XmS6.CHAR_BACKWARD_SLASH;
var $1e0430853cfb927a$require$CHAR_COMMA = $7XmS6.CHAR_COMMA;
var $1e0430853cfb927a$require$CHAR_DOT = $7XmS6.CHAR_DOT;
var $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK = $7XmS6.CHAR_EXCLAMATION_MARK;
var $1e0430853cfb927a$require$CHAR_FORWARD_SLASH = $7XmS6.CHAR_FORWARD_SLASH;
var $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE = $7XmS6.CHAR_LEFT_CURLY_BRACE;
var $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES = $7XmS6.CHAR_LEFT_PARENTHESES;
var $1e0430853cfb927a$require$CHAR_LEFT_SQUARE_BRACKET = $7XmS6.CHAR_LEFT_SQUARE_BRACKET;
var $1e0430853cfb927a$require$CHAR_PLUS = $7XmS6.CHAR_PLUS;
var $1e0430853cfb927a$require$CHAR_QUESTION_MARK = $7XmS6.CHAR_QUESTION_MARK;
var $1e0430853cfb927a$require$CHAR_RIGHT_CURLY_BRACE = $7XmS6.CHAR_RIGHT_CURLY_BRACE;
var $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES = $7XmS6.CHAR_RIGHT_PARENTHESES;
var $1e0430853cfb927a$require$CHAR_RIGHT_SQUARE_BRACKET = $7XmS6.CHAR_RIGHT_SQUARE_BRACKET;
const $1e0430853cfb927a$var$isPathSeparator = (code)=>{
    return code === $1e0430853cfb927a$require$CHAR_FORWARD_SLASH || code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH;
};
const $1e0430853cfb927a$var$depth = (token)=>{
    if (token.isPrefix !== true) token.depth = token.isGlobstar ? Infinity : 1;
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */ const $1e0430853cfb927a$var$scan = (input, options)=>{
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
        value: "",
        depth: 0,
        isGlob: false
    };
    const eos = ()=>index >= length;
    const peek = ()=>str.charCodeAt(index + 1);
    const advance = ()=>{
        prev = code;
        return str.charCodeAt(++index);
    };
    while(index < length){
        code = advance();
        let next;
        if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) braceEscaped = true;
            continue;
        }
        if (braceEscaped === true || code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while(eos() !== true && (code = advance())){
                if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === $1e0430853cfb927a$require$CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === $1e0430853cfb927a$require$CHAR_DOT && (code = advance()) === $1e0430853cfb927a$require$CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (braceEscaped !== true && code === $1e0430853cfb927a$require$CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (code === $1e0430853cfb927a$require$CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = {
                value: "",
                depth: 0,
                isGlob: false
            };
            if (finished === true) continue;
            if (prev === $1e0430853cfb927a$require$CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            const isExtglobChar = code === $1e0430853cfb927a$require$CHAR_PLUS || code === $1e0430853cfb927a$require$CHAR_AT || code === $1e0430853cfb927a$require$CHAR_ASTERISK || code === $1e0430853cfb927a$require$CHAR_QUESTION_MARK || code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK && index === start) negatedExtglob = true;
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === $1e0430853cfb927a$require$CHAR_ASTERISK) {
            if (prev === $1e0430853cfb927a$require$CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $1e0430853cfb927a$require$CHAR_LEFT_SQUARE_BRACKET) {
            while(eos() !== true && (next = advance())){
                if (next === $1e0430853cfb927a$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === $1e0430853cfb927a$require$CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (opts.nonegate !== true && code === $1e0430853cfb927a$require$CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while(eos() !== true && (code = advance())){
                    if (code === $1e0430853cfb927a$require$CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === $1e0430853cfb927a$require$CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    } else if (isGlob === true) {
        base = "";
        glob = str;
    } else base = str;
    if (base && base !== "" && base !== "/" && base !== str) {
        if ($1e0430853cfb927a$var$isPathSeparator(base.charCodeAt(base.length - 1))) base = base.slice(0, -1);
    }
    if (opts.unescape === true) {
        if (glob) glob = $5MQDC.removeBackslashes(glob);
        if (base && backslashes === true) base = $5MQDC.removeBackslashes(base);
    }
    const state = {
        prefix: prefix,
        input: input,
        start: start,
        base: base,
        glob: glob,
        isBrace: isBrace,
        isBracket: isBracket,
        isGlob: isGlob,
        isExtglob: isExtglob,
        isGlobstar: isGlobstar,
        negated: negated,
        negatedExtglob: negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!$1e0430853cfb927a$var$isPathSeparator(code)) tokens.push(token);
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for(let idx = 0; idx < slashes.length; idx++){
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                } else tokens[idx].value = value;
                $1e0430853cfb927a$var$depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") parts.push(value);
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            const value1 = input.slice(prevIndex + 1);
            parts.push(value1);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value1;
                $1e0430853cfb927a$var$depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = $1e0430853cfb927a$var$scan;

});
parcelRequire.register("5MQDC", function(module, exports) {

$parcel$export(module.exports, "isObject", () => $436a44408af843d4$export$a6cdc56e425d0d0a, (v) => $436a44408af843d4$export$a6cdc56e425d0d0a = v);
$parcel$export(module.exports, "hasRegexChars", () => $436a44408af843d4$export$6540a013a39bb50d, (v) => $436a44408af843d4$export$6540a013a39bb50d = v);
$parcel$export(module.exports, "escapeRegex", () => $436a44408af843d4$export$104ed90cc1a13451, (v) => $436a44408af843d4$export$104ed90cc1a13451 = v);
$parcel$export(module.exports, "toPosixSlashes", () => $436a44408af843d4$export$e610e037975797ee, (v) => $436a44408af843d4$export$e610e037975797ee = v);
$parcel$export(module.exports, "removeBackslashes", () => $436a44408af843d4$export$f403de0a7ba7a743, (v) => $436a44408af843d4$export$f403de0a7ba7a743 = v);
$parcel$export(module.exports, "supportsLookbehinds", () => $436a44408af843d4$export$bcf709e5e3483cdb, (v) => $436a44408af843d4$export$bcf709e5e3483cdb = v);
$parcel$export(module.exports, "isWindows", () => $436a44408af843d4$export$f993c945890e93ba, (v) => $436a44408af843d4$export$f993c945890e93ba = v);
$parcel$export(module.exports, "escapeLast", () => $436a44408af843d4$export$13d0f4185f159c8, (v) => $436a44408af843d4$export$13d0f4185f159c8 = v);
$parcel$export(module.exports, "removePrefix", () => $436a44408af843d4$export$f2888183a34644d4, (v) => $436a44408af843d4$export$f2888183a34644d4 = v);
$parcel$export(module.exports, "wrapOutput", () => $436a44408af843d4$export$25bddda26836484b, (v) => $436a44408af843d4$export$25bddda26836484b = v);
var $436a44408af843d4$export$a6cdc56e425d0d0a;
var $436a44408af843d4$export$6540a013a39bb50d;
var $436a44408af843d4$export$a92319f7ab133839;
var $436a44408af843d4$export$104ed90cc1a13451;
var $436a44408af843d4$export$e610e037975797ee;
var $436a44408af843d4$export$f403de0a7ba7a743;
var $436a44408af843d4$export$bcf709e5e3483cdb;
var $436a44408af843d4$export$f993c945890e93ba;
var $436a44408af843d4$export$13d0f4185f159c8;
var $436a44408af843d4$export$f2888183a34644d4;
var $436a44408af843d4$export$25bddda26836484b;
"use strict";

const $436a44408af843d4$var$win32 = process.platform === "win32";

var $7XmS6 = parcelRequire("7XmS6");
var $436a44408af843d4$require$REGEX_BACKSLASH = $7XmS6.REGEX_BACKSLASH;
var $436a44408af843d4$require$REGEX_REMOVE_BACKSLASH = $7XmS6.REGEX_REMOVE_BACKSLASH;
var $436a44408af843d4$require$REGEX_SPECIAL_CHARS = $7XmS6.REGEX_SPECIAL_CHARS;
var $436a44408af843d4$require$REGEX_SPECIAL_CHARS_GLOBAL = $7XmS6.REGEX_SPECIAL_CHARS_GLOBAL;
$436a44408af843d4$export$a6cdc56e425d0d0a = (val)=>val !== null && typeof val === "object" && !Array.isArray(val);
$436a44408af843d4$export$6540a013a39bb50d = (str)=>$436a44408af843d4$require$REGEX_SPECIAL_CHARS.test(str);
$436a44408af843d4$export$a92319f7ab133839 = (str)=>str.length === 1 && $436a44408af843d4$export$6540a013a39bb50d(str);
$436a44408af843d4$export$104ed90cc1a13451 = (str)=>str.replace($436a44408af843d4$require$REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
$436a44408af843d4$export$e610e037975797ee = (str)=>str.replace($436a44408af843d4$require$REGEX_BACKSLASH, "/");
$436a44408af843d4$export$f403de0a7ba7a743 = (str)=>{
    return str.replace($436a44408af843d4$require$REGEX_REMOVE_BACKSLASH, (match)=>{
        return match === "\\" ? "" : match;
    });
};
$436a44408af843d4$export$bcf709e5e3483cdb = ()=>{
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) return true;
    return false;
};
$436a44408af843d4$export$f993c945890e93ba = (options)=>{
    if (options && typeof options.windows === "boolean") return options.windows;
    return $436a44408af843d4$var$win32 === true || $8C1kk$path.sep === "\\";
};
$436a44408af843d4$export$13d0f4185f159c8 = (input, char, lastIdx)=>{
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === "\\") return $436a44408af843d4$export$13d0f4185f159c8(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};
$436a44408af843d4$export$f2888183a34644d4 = (input, state = {})=>{
    let output = input;
    if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
    }
    return output;
};
$436a44408af843d4$export$25bddda26836484b = (input, state = {}, options = {})=>{
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) output = `(?:^(?!${output}).*$)`;
    return output;
};

});
parcelRequire.register("7XmS6", function(module, exports) {
"use strict";

const $017eb4c9ec326d4f$var$WIN_SLASH = "\\\\/";
const $017eb4c9ec326d4f$var$WIN_NO_SLASH = `[^${$017eb4c9ec326d4f$var$WIN_SLASH}]`;
/**
 * Posix glob regex
 */ const $017eb4c9ec326d4f$var$DOT_LITERAL = "\\.";
const $017eb4c9ec326d4f$var$PLUS_LITERAL = "\\+";
const $017eb4c9ec326d4f$var$QMARK_LITERAL = "\\?";
const $017eb4c9ec326d4f$var$SLASH_LITERAL = "\\/";
const $017eb4c9ec326d4f$var$ONE_CHAR = "(?=.)";
const $017eb4c9ec326d4f$var$QMARK = "[^/]";
const $017eb4c9ec326d4f$var$END_ANCHOR = `(?:${$017eb4c9ec326d4f$var$SLASH_LITERAL}|$)`;
const $017eb4c9ec326d4f$var$START_ANCHOR = `(?:^|${$017eb4c9ec326d4f$var$SLASH_LITERAL})`;
const $017eb4c9ec326d4f$var$DOTS_SLASH = `${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}${$017eb4c9ec326d4f$var$END_ANCHOR}`;
const $017eb4c9ec326d4f$var$NO_DOT = `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL})`;
const $017eb4c9ec326d4f$var$NO_DOTS = `(?!${$017eb4c9ec326d4f$var$START_ANCHOR}${$017eb4c9ec326d4f$var$DOTS_SLASH})`;
const $017eb4c9ec326d4f$var$NO_DOT_SLASH = `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{0,1}${$017eb4c9ec326d4f$var$END_ANCHOR})`;
const $017eb4c9ec326d4f$var$NO_DOTS_SLASH = `(?!${$017eb4c9ec326d4f$var$DOTS_SLASH})`;
const $017eb4c9ec326d4f$var$QMARK_NO_DOT = `[^.${$017eb4c9ec326d4f$var$SLASH_LITERAL}]`;
const $017eb4c9ec326d4f$var$STAR = `${$017eb4c9ec326d4f$var$QMARK}*?`;
const $017eb4c9ec326d4f$var$POSIX_CHARS = {
    DOT_LITERAL: $017eb4c9ec326d4f$var$DOT_LITERAL,
    PLUS_LITERAL: $017eb4c9ec326d4f$var$PLUS_LITERAL,
    QMARK_LITERAL: $017eb4c9ec326d4f$var$QMARK_LITERAL,
    SLASH_LITERAL: $017eb4c9ec326d4f$var$SLASH_LITERAL,
    ONE_CHAR: $017eb4c9ec326d4f$var$ONE_CHAR,
    QMARK: $017eb4c9ec326d4f$var$QMARK,
    END_ANCHOR: $017eb4c9ec326d4f$var$END_ANCHOR,
    DOTS_SLASH: $017eb4c9ec326d4f$var$DOTS_SLASH,
    NO_DOT: $017eb4c9ec326d4f$var$NO_DOT,
    NO_DOTS: $017eb4c9ec326d4f$var$NO_DOTS,
    NO_DOT_SLASH: $017eb4c9ec326d4f$var$NO_DOT_SLASH,
    NO_DOTS_SLASH: $017eb4c9ec326d4f$var$NO_DOTS_SLASH,
    QMARK_NO_DOT: $017eb4c9ec326d4f$var$QMARK_NO_DOT,
    STAR: $017eb4c9ec326d4f$var$STAR,
    START_ANCHOR: $017eb4c9ec326d4f$var$START_ANCHOR
};
/**
 * Windows glob regex
 */ const $017eb4c9ec326d4f$var$WINDOWS_CHARS = {
    ...$017eb4c9ec326d4f$var$POSIX_CHARS,
    SLASH_LITERAL: `[${$017eb4c9ec326d4f$var$WIN_SLASH}]`,
    QMARK: $017eb4c9ec326d4f$var$WIN_NO_SLASH,
    STAR: `${$017eb4c9ec326d4f$var$WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$)`,
    NO_DOT: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${$017eb4c9ec326d4f$var$WIN_SLASH}])${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{0,1}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${$017eb4c9ec326d4f$var$DOT_LITERAL}{1,2}(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${$017eb4c9ec326d4f$var$WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${$017eb4c9ec326d4f$var$WIN_SLASH}])`,
    END_ANCHOR: `(?:[${$017eb4c9ec326d4f$var$WIN_SLASH}]|$)`
};
/**
 * POSIX Bracket Regex
 */ const $017eb4c9ec326d4f$var$POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
};
module.exports = {
    MAX_LENGTH: 65536,
    POSIX_REGEX_SOURCE: $017eb4c9ec326d4f$var$POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */ CHAR_9: 57,
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */ CHAR_LOWERCASE_A: 97,
    /* a */ CHAR_UPPERCASE_Z: 90,
    /* Z */ CHAR_LOWERCASE_Z: 122,
    /* z */ CHAR_LEFT_PARENTHESES: 40,
    /* ( */ CHAR_RIGHT_PARENTHESES: 41,
    /* ) */ CHAR_ASTERISK: 42,
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */ CHAR_AT: 64,
    /* @ */ CHAR_BACKWARD_SLASH: 92,
    /* \ */ CHAR_CARRIAGE_RETURN: 13,
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */ CHAR_COLON: 58,
    /* : */ CHAR_COMMA: 44,
    /* , */ CHAR_DOT: 46,
    /* . */ CHAR_DOUBLE_QUOTE: 34,
    /* " */ CHAR_EQUAL: 61,
    /* = */ CHAR_EXCLAMATION_MARK: 33,
    /* ! */ CHAR_FORM_FEED: 12,
    /* \f */ CHAR_FORWARD_SLASH: 47,
    /* / */ CHAR_GRAVE_ACCENT: 96,
    /* ` */ CHAR_HASH: 35,
    /* # */ CHAR_HYPHEN_MINUS: 45,
    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */ CHAR_LEFT_CURLY_BRACE: 123,
    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */ CHAR_LINE_FEED: 10,
    /* \n */ CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */ CHAR_PERCENT: 37,
    /* % */ CHAR_PLUS: 43,
    /* + */ CHAR_QUESTION_MARK: 63,
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */ CHAR_SEMICOLON: 59,
    /* ; */ CHAR_SINGLE_QUOTE: 39,
    /* ' */ CHAR_SPACE: 32,
    /*   */ CHAR_TAB: 9,
    /* \t */ CHAR_UNDERSCORE: 95,
    /* _ */ CHAR_VERTICAL_LINE: 124,
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */ SEP: $8C1kk$path.sep,
    /**
   * Create EXTGLOB_CHARS
   */ extglobChars (chars) {
        return {
            "!": {
                type: "negate",
                open: "(?:(?!(?:",
                close: `))${chars.STAR})`
            },
            "?": {
                type: "qmark",
                open: "(?:",
                close: ")?"
            },
            "+": {
                type: "plus",
                open: "(?:",
                close: ")+"
            },
            "*": {
                type: "star",
                open: "(?:",
                close: ")*"
            },
            "@": {
                type: "at",
                open: "(?:",
                close: ")"
            }
        };
    },
    /**
   * Create GLOB_CHARS
   */ globChars (win32) {
        return win32 === true ? $017eb4c9ec326d4f$var$WINDOWS_CHARS : $017eb4c9ec326d4f$var$POSIX_CHARS;
    }
};

});



parcelRequire.register("lKEF0", function(module, exports) {
"use strict";

var $7XmS6 = parcelRequire("7XmS6");

var $5MQDC = parcelRequire("5MQDC");
/**
 * Constants
 */ const { MAX_LENGTH: $fd5d6f248e5b4a63$var$MAX_LENGTH , POSIX_REGEX_SOURCE: $fd5d6f248e5b4a63$var$POSIX_REGEX_SOURCE , REGEX_NON_SPECIAL_CHARS: $fd5d6f248e5b4a63$var$REGEX_NON_SPECIAL_CHARS , REGEX_SPECIAL_CHARS_BACKREF: $fd5d6f248e5b4a63$var$REGEX_SPECIAL_CHARS_BACKREF , REPLACEMENTS: $fd5d6f248e5b4a63$var$REPLACEMENTS  } = $7XmS6;
/**
 * Helpers
 */ const $fd5d6f248e5b4a63$var$expandRange = (args, options)=>{
    if (typeof options.expandRange === "function") return options.expandRange(...args, options);
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
        /* eslint-disable-next-line no-new */ new RegExp(value);
    } catch (ex) {
        return args.map((v)=>$5MQDC.escapeRegex(v)).join("..");
    }
    return value;
};
/**
 * Create the message for a syntax error
 */ const $fd5d6f248e5b4a63$var$syntaxError = (type, char)=>{
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */ const $fd5d6f248e5b4a63$var$parse = (input, options)=>{
    if (typeof input !== "string") throw new TypeError("Expected a string");
    input = $fd5d6f248e5b4a63$var$REPLACEMENTS[input] || input;
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($fd5d6f248e5b4a63$var$MAX_LENGTH, opts.maxLength) : $fd5d6f248e5b4a63$var$MAX_LENGTH;
    let len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    const bos = {
        type: "bos",
        value: "",
        output: opts.prepend || ""
    };
    const tokens = [
        bos
    ];
    const capture = opts.capture ? "" : "?:";
    const win32 = $5MQDC.isWindows(options);
    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = $7XmS6.globChars(win32);
    const EXTGLOB_CHARS = $7XmS6.extglobChars(PLATFORM_CHARS);
    const { DOT_LITERAL: DOT_LITERAL , PLUS_LITERAL: PLUS_LITERAL , SLASH_LITERAL: SLASH_LITERAL , ONE_CHAR: ONE_CHAR , DOTS_SLASH: DOTS_SLASH , NO_DOT: NO_DOT , NO_DOT_SLASH: NO_DOT_SLASH , NO_DOTS_SLASH: NO_DOTS_SLASH , QMARK: QMARK , QMARK_NO_DOT: QMARK_NO_DOT , STAR: STAR , START_ANCHOR: START_ANCHOR  } = PLATFORM_CHARS;
    const globstar = (opts)=>{
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) star = `(${star})`;
    // minimatch options support
    if (typeof opts.noext === "boolean") opts.noextglob = opts.noext;
    const state = {
        input: input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens: tokens
    };
    input = $5MQDC.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
   * Tokenizing helpers
   */ const eos = ()=>state.index === len - 1;
    const peek = state.peek = (n = 1)=>input[state.index + n];
    const advance = state.advance = ()=>input[++state.index] || "";
    const remaining = ()=>input.slice(state.index + 1);
    const consume = (value = "", num = 0)=>{
        state.consumed += value;
        state.index += num;
    };
    const append = (token)=>{
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    const negate = ()=>{
        let count = 1;
        while(peek() === "!" && (peek(2) !== "(" || peek(3) === "?")){
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) return false;
        state.negated = true;
        state.start++;
        return true;
    };
    const increment = (type)=>{
        state[type]++;
        stack.push(type);
    };
    const decrement = (type)=>{
        state[type]--;
        stack.pop();
    };
    /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */ const push = (tok)=>{
        if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = "star";
                prev.value = "*";
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== "paren") extglobs[extglobs.length - 1].inner += tok.value;
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    const extglobOpen = (type, value)=>{
        const token = {
            ...EXTGLOB_CHARS[value],
            conditions: 1,
            inner: ""
        };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({
            type: type,
            value: value,
            output: state.output ? "" : ONE_CHAR
        });
        push({
            type: "paren",
            extglob: true,
            value: advance(),
            output: output
        });
        extglobs.push(token);
    };
    const extglobClose = (token)=>{
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) extglobStar = globstar(opts);
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) output = token.close = `)$))${extglobStar}`;
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) output = token.close = `)${rest})${extglobStar})`;
            if (token.prev.type === "bos") state.negatedExtglob = true;
        }
        push({
            type: "paren",
            extglob: true,
            value: value,
            output: output
        });
        decrement("parens");
    };
    /**
   * Fast paths
   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace($fd5d6f248e5b4a63$var$REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
            if (first === "\\") {
                backslashes = true;
                return m;
            }
            if (first === "?") {
                if (esc) return esc + first + (rest ? QMARK.repeat(rest.length) : "");
                if (index === 0) return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
                return QMARK.repeat(chars.length);
            }
            if (first === ".") return DOT_LITERAL.repeat(chars.length);
            if (first === "*") {
                if (esc) return esc + first + (rest ? star : "");
                return star;
            }
            return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
            if (opts.unescape === true) output = output.replace(/\\/g, "");
            else output = output.replace(/\\+/g, (m)=>{
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = $5MQDC.wrapOutput(output, state, options);
        return state;
    }
    /**
   * Tokenize input until we reach end-of-string
   */ while(!eos()){
        value = advance();
        if (value === "\0") continue;
        /**
     * Escaped characters
     */ if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) continue;
            if (next === "." || next === ";") continue;
            if (!next) {
                value += "\\";
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) value += "\\";
            }
            if (opts.unescape === true) value = advance();
            else value += advance();
            if (state.brackets === 0) {
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
        }
        /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */ if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
                const inner = prev.value.slice(1);
                if (inner.includes("[")) {
                    prev.posix = true;
                    if (inner.includes(":")) {
                        const idx = prev.value.lastIndexOf("[");
                        const pre = prev.value.slice(0, idx);
                        const rest = prev.value.slice(idx + 2);
                        const posix = $fd5d6f248e5b4a63$var$POSIX_REGEX_SOURCE[rest];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) bos.output = ONE_CHAR;
                            continue;
                        }
                    }
                }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") value = `\\${value}`;
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) value = `\\${value}`;
            if (opts.posix === true && value === "!" && prev.value === "[") value = "^";
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */ if (state.quotes === 1 && value !== '"') {
            value = $5MQDC.escapeRegex(value);
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * Double quotes
     */ if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Parentheses
     */ if (value === "(") {
            increment("parens");
            push({
                type: "paren",
                value: value
            });
            continue;
        }
        if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("opening", "("));
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({
                type: "paren",
                value: value,
                output: state.parens ? ")" : "\\)"
            });
            decrement("parens");
            continue;
        }
        /**
     * Square brackets
     */ if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
                if (opts.nobracket !== true && opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "]"));
                value = `\\${value}`;
            } else increment("brackets");
            push({
                type: "bracket",
                value: value
            });
            continue;
        }
        if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("opening", "["));
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) value = `/${value}`;
            prev.value += value;
            append({
                value: value
            });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || $5MQDC.hasRegexChars(prevValue)) continue;
            const escaped = $5MQDC.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
        }
        /**
     * Braces
     */ if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
                type: "brace",
                value: value,
                output: "(",
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
        }
        if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
                push({
                    type: "text",
                    value: value,
                    output: value
                });
                continue;
            }
            let output1 = ")";
            if (brace.dots === true) {
                const arr = tokens.slice();
                const range = [];
                for(let i = arr.length - 1; i >= 0; i--){
                    tokens.pop();
                    if (arr[i].type === "brace") break;
                    if (arr[i].type !== "dots") range.unshift(arr[i].value);
                }
                output1 = $fd5d6f248e5b4a63$var$expandRange(range, opts);
                state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
                const out = state.output.slice(0, brace.outputIndex);
                const toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = "\\{";
                value = output1 = "\\}";
                state.output = out;
                for (const t of toks)state.output += t.output || t.value;
            }
            push({
                type: "brace",
                value: value,
                output: output1
            });
            decrement("braces");
            braces.pop();
            continue;
        }
        /**
     * Pipes
     */ if (value === "|") {
            if (extglobs.length > 0) extglobs[extglobs.length - 1].conditions++;
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Commas
     */ if (value === ",") {
            let output2 = value;
            const brace1 = braces[braces.length - 1];
            if (brace1 && stack[stack.length - 1] === "braces") {
                brace1.comma = true;
                output2 = "|";
            }
            push({
                type: "comma",
                value: value,
                output: output2
            });
            continue;
        }
        /**
     * Slashes
     */ if (value === "/") {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === "dot" && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = "";
                state.output = "";
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({
                type: "slash",
                value: value,
                output: SLASH_LITERAL
            });
            continue;
        }
        /**
     * Dots
     */ if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
                if (prev.value === ".") prev.output = DOT_LITERAL;
                const brace2 = braces[braces.length - 1];
                prev.type = "dots";
                prev.output += value;
                prev.value += value;
                brace2.dots = true;
                continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
                push({
                    type: "text",
                    value: value,
                    output: DOT_LITERAL
                });
                continue;
            }
            push({
                type: "dot",
                value: value,
                output: DOT_LITERAL
            });
            continue;
        }
        /**
     * Question marks
     */ if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("qmark", value);
                continue;
            }
            if (prev && prev.type === "paren") {
                const next1 = peek();
                let output3 = value;
                if (next1 === "<" && !$5MQDC.supportsLookbehinds()) throw new Error("Node.js v10 or higher is required for regex lookbehinds");
                if (prev.value === "(" && !/[!=<:]/.test(next1) || next1 === "<" && !/<([!=]|\w+>)/.test(remaining())) output3 = `\\${value}`;
                push({
                    type: "text",
                    value: value,
                    output: output3
                });
                continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
                push({
                    type: "qmark",
                    value: value,
                    output: QMARK_NO_DOT
                });
                continue;
            }
            push({
                type: "qmark",
                value: value,
                output: QMARK
            });
            continue;
        }
        /**
     * Exclamation
     */ if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
                if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                    extglobOpen("negate", value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate();
                continue;
            }
        }
        /**
     * Plus
     */ if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("plus", value);
                continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
                push({
                    type: "plus",
                    value: value,
                    output: PLUS_LITERAL
                });
                continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
                push({
                    type: "plus",
                    value: value
                });
                continue;
            }
            push({
                type: "plus",
                value: PLUS_LITERAL
            });
            continue;
        }
        /**
     * Plain text
     */ if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                push({
                    type: "at",
                    extglob: true,
                    value: value,
                    output: ""
                });
                continue;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Plain text
     */ if (value !== "*") {
            if (value === "$" || value === "^") value = `\\${value}`;
            const match1 = $fd5d6f248e5b4a63$var$REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match1) {
                value += match1[0];
                state.index += match1[0].length;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Stars
     */ if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
        }
        let rest1 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest1)) {
            extglobOpen("star", value);
            continue;
        }
        if (prev.type === "star") {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest1[0] && rest1[0] !== "/")) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            // strip consecutive `/**/`
            while(rest1.slice(0, 3) === "/**"){
                const after = input[state.index + 4];
                if (after && after !== "/") break;
                rest1 = rest1.slice(3);
                consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
                prev.type = "globstar";
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
                prev.value += value;
                state.globstar = true;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest1[0] === "/") {
                const end = rest1[1] !== void 0 ? "|$" : "";
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                prev.value += value;
                state.output += prior.output + prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            if (prior.type === "bos" && rest1[0] === "/") {
                prev.type = "globstar";
                prev.value += value;
                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                state.output = prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
        }
        const token = {
            type: "star",
            value: value,
            output: star
        };
        if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") token.output = nodot + token.output;
            push(token);
            continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            } else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== "*") {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while(state.brackets > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "]"));
        state.output = $5MQDC.escapeLast(state.output, "[");
        decrement("brackets");
    }
    while(state.parens > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", ")"));
        state.output = $5MQDC.escapeLast(state.output, "(");
        decrement("parens");
    }
    while(state.braces > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($fd5d6f248e5b4a63$var$syntaxError("closing", "}"));
        state.output = $5MQDC.escapeLast(state.output, "{");
        decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) push({
        type: "maybe_slash",
        value: "",
        output: `${SLASH_LITERAL}?`
    });
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = "";
        for (const token1 of state.tokens){
            state.output += token1.output != null ? token1.output : token1.value;
            if (token1.suffix) state.output += token1.suffix;
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */ $fd5d6f248e5b4a63$var$parse.fastpaths = (input, options)=>{
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($fd5d6f248e5b4a63$var$MAX_LENGTH, opts.maxLength) : $fd5d6f248e5b4a63$var$MAX_LENGTH;
    const len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    input = $fd5d6f248e5b4a63$var$REPLACEMENTS[input] || input;
    const win32 = $5MQDC.isWindows(options);
    // create constants based on platform, for windows or posix
    const { DOT_LITERAL: DOT_LITERAL , SLASH_LITERAL: SLASH_LITERAL , ONE_CHAR: ONE_CHAR , DOTS_SLASH: DOTS_SLASH , NO_DOT: NO_DOT , NO_DOTS: NO_DOTS , NO_DOTS_SLASH: NO_DOTS_SLASH , STAR: STAR , START_ANCHOR: START_ANCHOR  } = $7XmS6.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {
        negated: false,
        prefix: ""
    };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) star = `(${star})`;
    const globstar = (opts)=>{
        if (opts.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str)=>{
        switch(str){
            case "*":
                return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
                return nodot + globstar(opts);
            case "**/*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default:
                {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match) return;
                    const source = create(match[1]);
                    if (!source) return;
                    return source + DOT_LITERAL + match[2];
                }
        }
    };
    const output = $5MQDC.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) source += `${SLASH_LITERAL}?`;
    return source;
};
module.exports = $fd5d6f248e5b4a63$var$parse;

});


parcelRequire.register("5SlBN", function(module, exports) {
"use strict";

module.exports = (parcelRequire("5cGv8"));

module.exports.async = (parcelRequire("9s5mZ"));

module.exports.stream = (parcelRequire("kV1zV"));

module.exports.prettyError = (parcelRequire("ciuZ9"));

});
parcelRequire.register("5cGv8", function(module, exports) {
"use strict";
module.exports = $3c9f0a8fecf863f4$var$parseString;

var $1Sf6D = parcelRequire("1Sf6D");

var $ciuZ9 = parcelRequire("ciuZ9");
function $3c9f0a8fecf863f4$var$parseString(str) {
    if ($parcel$global.Buffer && $parcel$global.Buffer.isBuffer(str)) str = str.toString("utf8");
    const parser = new $1Sf6D();
    try {
        parser.parse(str);
        return parser.finish();
    } catch (err) {
        throw $ciuZ9(err, str);
    }
}

});
parcelRequire.register("1Sf6D", function(module, exports) {
"use strict";

/* eslint-disable no-new-wrappers, no-eval, camelcase, operator-linebreak */ module.exports = makeParserClass((parcelRequire("8E52p")));
module.exports.makeParserClass = makeParserClass;
class TomlError extends Error {
    constructor(msg){
        super(msg);
        this.name = "TomlError";
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, TomlError);
        this.fromTOML = true;
        this.wrapped = null;
    }
}
TomlError.wrap = (err)=>{
    const terr = new TomlError(err.message);
    terr.code = err.code;
    terr.wrapped = err;
    return terr;
};
module.exports.TomlError = TomlError;

var $bS2MF = parcelRequire("bS2MF");

var $9dYMx = parcelRequire("9dYMx");

var $gbrcb = parcelRequire("gbrcb");

var $636jz = parcelRequire("636jz");
const CTRL_I = 0x09;
const CTRL_J = 0x0A;
const CTRL_M = 0x0D;
const CTRL_CHAR_BOUNDARY = 0x1F // the last non-character in the latin1 region of unicode, except DEL
;
const CHAR_SP = 0x20;
const CHAR_QUOT = 0x22;
const CHAR_NUM = 0x23;
const CHAR_APOS = 0x27;
const CHAR_PLUS = 0x2B;
const CHAR_COMMA = 0x2C;
const CHAR_HYPHEN = 0x2D;
const CHAR_PERIOD = 0x2E;
const CHAR_0 = 0x30;
const CHAR_1 = 0x31;
const CHAR_7 = 0x37;
const CHAR_9 = 0x39;
const CHAR_COLON = 0x3A;
const CHAR_EQUALS = 0x3D;
const CHAR_A = 0x41;
const CHAR_E = 0x45;
const CHAR_F = 0x46;
const CHAR_T = 0x54;
const CHAR_U = 0x55;
const CHAR_Z = 0x5A;
const CHAR_LOWBAR = 0x5F;
const CHAR_a = 0x61;
const CHAR_b = 0x62;
const CHAR_e = 0x65;
const CHAR_f = 0x66;
const CHAR_i = 0x69;
const CHAR_l = 0x6C;
const CHAR_n = 0x6E;
const CHAR_o = 0x6F;
const CHAR_r = 0x72;
const CHAR_s = 0x73;
const CHAR_t = 0x74;
const CHAR_u = 0x75;
const CHAR_x = 0x78;
const CHAR_z = 0x7A;
const CHAR_LCUB = 0x7B;
const CHAR_RCUB = 0x7D;
const CHAR_LSQB = 0x5B;
const CHAR_BSOL = 0x5C;
const CHAR_RSQB = 0x5D;
const CHAR_DEL = 0x7F;
const SURROGATE_FIRST = 0xD800;
const SURROGATE_LAST = 0xDFFF;
const escapes = {
    [CHAR_b]: "\b",
    [CHAR_t]: "	",
    [CHAR_n]: "\n",
    [CHAR_f]: "\f",
    [CHAR_r]: "\r",
    [CHAR_QUOT]: '"',
    [CHAR_BSOL]: "\\"
};
function isDigit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_9;
}
function isHexit(cp) {
    return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
}
function isBit(cp) {
    return cp === CHAR_1 || cp === CHAR_0;
}
function isOctit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_7;
}
function isAlphaNumQuoteHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
function isAlphaNumHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
const _type = Symbol("type");
const _declared = Symbol("declared");
const hasOwnProperty = Object.prototype.hasOwnProperty;
const defineProperty = Object.defineProperty;
const descriptor = {
    configurable: true,
    enumerable: true,
    writable: true,
    value: undefined
};
function hasKey(obj, key) {
    if (hasOwnProperty.call(obj, key)) return true;
    if (key === "__proto__") defineProperty(obj, "__proto__", descriptor);
    return false;
}
const INLINE_TABLE = Symbol("inline-table");
function InlineTable() {
    return Object.defineProperties({}, {
        [_type]: {
            value: INLINE_TABLE
        }
    });
}
function isInlineTable(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INLINE_TABLE;
}
const TABLE = Symbol("table");
function Table() {
    return Object.defineProperties({}, {
        [_type]: {
            value: TABLE
        },
        [_declared]: {
            value: false,
            writable: true
        }
    });
}
function isTable(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === TABLE;
}
const _contentType = Symbol("content-type");
const INLINE_LIST = Symbol("inline-list");
function InlineList(type) {
    return Object.defineProperties([], {
        [_type]: {
            value: INLINE_LIST
        },
        [_contentType]: {
            value: type
        }
    });
}
function isInlineList(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INLINE_LIST;
}
const LIST = Symbol("list");
function List() {
    return Object.defineProperties([], {
        [_type]: {
            value: LIST
        }
    });
}
function isList(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === LIST;
}
// in an eval, to let bundlers not slurp in a util proxy
let _custom;
try {
    const utilInspect = eval("require('util').inspect");
    _custom = utilInspect.custom;
} catch (_) {
/* eval require not available in transpiled bundle */ }
/* istanbul ignore next */ const _inspect = _custom || "inspect";
class BoxedBigInt {
    constructor(value){
        try {
            this.value = $parcel$global.BigInt.asIntN(64, value);
        } catch (_) {
            /* istanbul ignore next */ this.value = null;
        }
        Object.defineProperty(this, _type, {
            value: INTEGER
        });
    }
    isNaN() {
        return this.value === null;
    }
    /* istanbul ignore next */ toString() {
        return String(this.value);
    }
    /* istanbul ignore next */ [_inspect]() {
        return `[BigInt: ${this.toString()}]}`;
    }
    valueOf() {
        return this.value;
    }
}
const INTEGER = Symbol("integer");
function Integer(value) {
    let num = Number(value);
    // -0 is a float thing, not an int thing
    if (Object.is(num, -0)) num = 0;
    /* istanbul ignore else */ if ($parcel$global.BigInt && !Number.isSafeInteger(num)) return new BoxedBigInt(value);
    else /* istanbul ignore next */ return Object.defineProperties(new Number(num), {
        isNaN: {
            value: function() {
                return isNaN(this);
            }
        },
        [_type]: {
            value: INTEGER
        },
        [_inspect]: {
            value: ()=>`[Integer: ${value}]`
        }
    });
}
function isInteger(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === INTEGER;
}
const FLOAT = Symbol("float");
function Float(value) {
    /* istanbul ignore next */ return Object.defineProperties(new Number(value), {
        [_type]: {
            value: FLOAT
        },
        [_inspect]: {
            value: ()=>`[Float: ${value}]`
        }
    });
}
function isFloat(obj) {
    if (obj === null || typeof obj !== "object") return false;
    return obj[_type] === FLOAT;
}
function tomlType(value) {
    const type = typeof value;
    if (type === "object") {
        /* istanbul ignore if */ if (value === null) return "null";
        if (value instanceof Date) return "datetime";
        /* istanbul ignore else */ if (_type in value) switch(value[_type]){
            case INLINE_TABLE:
                return "inline-table";
            case INLINE_LIST:
                return "inline-list";
            /* istanbul ignore next */ case TABLE:
                return "table";
            /* istanbul ignore next */ case LIST:
                return "list";
            case FLOAT:
                return "float";
            case INTEGER:
                return "integer";
        }
    }
    return type;
}
function makeParserClass(Parser) {
    class TOMLParser extends Parser {
        constructor(){
            super();
            this.ctx = this.obj = Table();
        }
        /* MATCH HELPER */ atEndOfWord() {
            return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
        }
        atEndOfLine() {
            return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
        }
        parseStart() {
            if (this.char === Parser.END) return null;
            else if (this.char === CHAR_LSQB) return this.call(this.parseTableOrList);
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else if (isAlphaNumQuoteHyphen(this.char)) return this.callNow(this.parseAssignStatement);
            else throw this.error(new TomlError(`Unknown character "${this.char}"`));
        }
        // HELPER, this strips any whitespace and comments to the end of the line
        // then RETURNS. Last state in a production.
        parseWhitespaceToEOL() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else if (this.char === CHAR_NUM) return this.goto(this.parseComment);
            else if (this.char === Parser.END || this.char === CTRL_J) return this.return();
            else throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
        }
        /* ASSIGNMENT: key = value */ parseAssignStatement() {
            return this.callNow(this.parseAssign, this.recordAssignStatement);
        }
        recordAssignStatement(kv) {
            let target = this.ctx;
            let finalKey = kv.key.pop();
            for (let kw of kv.key){
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                target = target[kw] = target[kw] || Table();
            }
            if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
            // unbox our numbers
            if (isInteger(kv.value) || isFloat(kv.value)) target[finalKey] = kv.value.valueOf();
            else target[finalKey] = kv.value;
            return this.goto(this.parseWhitespaceToEOL);
        }
        /* ASSSIGNMENT expression, key = value possibly inside an inline table */ parseAssign() {
            return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        recordAssignKeyword(key) {
            if (this.state.resultTable) this.state.resultTable.push(key);
            else this.state.resultTable = [
                key
            ];
            return this.goto(this.parseAssignKeywordPreDot);
        }
        parseAssignKeywordPreDot() {
            if (this.char === CHAR_PERIOD) return this.next(this.parseAssignKeywordPostDot);
            else if (this.char !== CHAR_SP && this.char !== CTRL_I) return this.goto(this.parseAssignEqual);
        }
        parseAssignKeywordPostDot() {
            if (this.char !== CHAR_SP && this.char !== CTRL_I) return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        parseAssignEqual() {
            if (this.char === CHAR_EQUALS) return this.next(this.parseAssignPreValue);
            else throw this.error(new TomlError('Invalid character, expected "="'));
        }
        parseAssignPreValue() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseValue, this.recordAssignValue);
        }
        recordAssignValue(value) {
            return this.returnNow({
                key: this.state.resultTable,
                value: value
            });
        }
        /* COMMENTS: #...eol */ parseComment() {
            do {
                if (this.char === Parser.END || this.char === CTRL_J) return this.return();
            }while (this.nextChar());
        }
        /* TABLES AND LISTS, [foo] and [[foo]] */ parseTableOrList() {
            if (this.char === CHAR_LSQB) this.next(this.parseList);
            else return this.goto(this.parseTable);
        }
        /* TABLE [foo.bar.baz] */ parseTable() {
            this.ctx = this.obj;
            return this.goto(this.parseTableNext);
        }
        parseTableNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseKeyword, this.parseTableMore);
        }
        parseTableMore(keyword) {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CHAR_RSQB) {
                if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                else {
                    this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
                    this.ctx[_declared] = true;
                }
                return this.next(this.parseWhitespaceToEOL);
            } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) this.ctx = this.ctx[keyword] = Table();
                else if (isTable(this.ctx[keyword])) this.ctx = this.ctx[keyword];
                else if (isList(this.ctx[keyword])) this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                else throw this.error(new TomlError("Can't redefine existing key"));
                return this.next(this.parseTableNext);
            } else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* LIST [[a.b.c]] */ parseList() {
            this.ctx = this.obj;
            return this.goto(this.parseListNext);
        }
        parseListNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else return this.callNow(this.parseKeyword, this.parseListMore);
        }
        parseListMore(keyword) {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CHAR_RSQB) {
                if (!hasKey(this.ctx, keyword)) this.ctx[keyword] = List();
                if (isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                else if (isList(this.ctx[keyword])) {
                    const next = Table();
                    this.ctx[keyword].push(next);
                    this.ctx = next;
                } else throw this.error(new TomlError("Can't redefine an existing key"));
                return this.next(this.parseListEnd);
            } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) this.ctx = this.ctx[keyword] = Table();
                else if (isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                else if (isInlineTable(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline table"));
                else if (isList(this.ctx[keyword])) this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                else if (isTable(this.ctx[keyword])) this.ctx = this.ctx[keyword];
                else throw this.error(new TomlError("Can't redefine an existing key"));
                return this.next(this.parseListNext);
            } else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        parseListEnd(keyword) {
            if (this.char === CHAR_RSQB) return this.next(this.parseWhitespaceToEOL);
            else throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* VALUE string, number, boolean, inline list, inline object */ parseValue() {
            if (this.char === Parser.END) throw this.error(new TomlError("Key without value"));
            else if (this.char === CHAR_QUOT) return this.next(this.parseDoubleString);
            if (this.char === CHAR_APOS) return this.next(this.parseSingleString);
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) return this.goto(this.parseNumberSign);
            else if (this.char === CHAR_i) return this.next(this.parseInf);
            else if (this.char === CHAR_n) return this.next(this.parseNan);
            else if (isDigit(this.char)) return this.goto(this.parseNumberOrDateTime);
            else if (this.char === CHAR_t || this.char === CHAR_f) return this.goto(this.parseBoolean);
            else if (this.char === CHAR_LSQB) return this.call(this.parseInlineList, this.recordValue);
            else if (this.char === CHAR_LCUB) return this.call(this.parseInlineTable, this.recordValue);
            else throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
        }
        recordValue(value) {
            return this.returnNow(value);
        }
        parseInf() {
            if (this.char === CHAR_n) return this.next(this.parseInf2);
            else throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseInf2() {
            if (this.char === CHAR_f) {
                if (this.state.buf === "-") return this.return(-Infinity);
                else return this.return(Infinity);
            } else throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseNan() {
            if (this.char === CHAR_a) return this.next(this.parseNan2);
            else throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        parseNan2() {
            if (this.char === CHAR_n) return this.return(NaN);
            else throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        /* KEYS, barewords or basic, literal, or dotted */ parseKeyword() {
            if (this.char === CHAR_QUOT) return this.next(this.parseBasicString);
            else if (this.char === CHAR_APOS) return this.next(this.parseLiteralString);
            else return this.goto(this.parseBareKey);
        }
        /* KEYS: barewords */ parseBareKey() {
            do {
                if (this.char === Parser.END) throw this.error(new TomlError("Key ended without value"));
                else if (isAlphaNumHyphen(this.char)) this.consume();
                else if (this.state.buf.length === 0) throw this.error(new TomlError("Empty bare keys are not allowed"));
                else return this.returnNow();
            }while (this.nextChar());
        }
        /* STRINGS, single quoted (literal) */ parseSingleString() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiStringMaybe);
            else return this.goto(this.parseLiteralString);
        }
        parseLiteralString() {
            do {
                if (this.char === CHAR_APOS) return this.return();
                else if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        parseLiteralMultiStringMaybe() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiString);
            else return this.returnNow();
        }
        parseLiteralMultiString() {
            if (this.char === CTRL_M) return null;
            else if (this.char === CTRL_J) return this.next(this.parseLiteralMultiStringContent);
            else return this.goto(this.parseLiteralMultiStringContent);
        }
        parseLiteralMultiStringContent() {
            do {
                if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiEnd);
                else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        parseLiteralMultiEnd() {
            if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiEnd2);
            else {
                this.state.buf += "'";
                return this.goto(this.parseLiteralMultiStringContent);
            }
        }
        parseLiteralMultiEnd2() {
            if (this.char === CHAR_APOS) return this.return();
            else {
                this.state.buf += "''";
                return this.goto(this.parseLiteralMultiStringContent);
            }
        }
        /* STRINGS double quoted */ parseDoubleString() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiStringMaybe);
            else return this.goto(this.parseBasicString);
        }
        parseBasicString() {
            do {
                if (this.char === CHAR_BSOL) return this.call(this.parseEscape, this.recordEscapeReplacement);
                else if (this.char === CHAR_QUOT) return this.return();
                else if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        recordEscapeReplacement(replacement) {
            this.state.buf += replacement;
            return this.goto(this.parseBasicString);
        }
        parseMultiStringMaybe() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiString);
            else return this.returnNow();
        }
        parseMultiString() {
            if (this.char === CTRL_M) return null;
            else if (this.char === CTRL_J) return this.next(this.parseMultiStringContent);
            else return this.goto(this.parseMultiStringContent);
        }
        parseMultiStringContent() {
            do {
                if (this.char === CHAR_BSOL) return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
                else if (this.char === CHAR_QUOT) return this.next(this.parseMultiEnd);
                else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                else this.consume();
            }while (this.nextChar());
        }
        errorControlCharInString() {
            let displayCode = "\\u00";
            if (this.char < 16) displayCode += "0";
            displayCode += this.char.toString(16);
            return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
        }
        recordMultiEscapeReplacement(replacement) {
            this.state.buf += replacement;
            return this.goto(this.parseMultiStringContent);
        }
        parseMultiEnd() {
            if (this.char === CHAR_QUOT) return this.next(this.parseMultiEnd2);
            else {
                this.state.buf += '"';
                return this.goto(this.parseMultiStringContent);
            }
        }
        parseMultiEnd2() {
            if (this.char === CHAR_QUOT) return this.return();
            else {
                this.state.buf += '""';
                return this.goto(this.parseMultiStringContent);
            }
        }
        parseMultiEscape() {
            if (this.char === CTRL_M || this.char === CTRL_J) return this.next(this.parseMultiTrim);
            else if (this.char === CHAR_SP || this.char === CTRL_I) return this.next(this.parsePreMultiTrim);
            else return this.goto(this.parseEscape);
        }
        parsePreMultiTrim() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === CTRL_M || this.char === CTRL_J) return this.next(this.parseMultiTrim);
            else throw this.error(new TomlError("Can't escape whitespace"));
        }
        parseMultiTrim() {
            // explicitly whitespace here, END should follow the same path as chars
            if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
            else return this.returnNow();
        }
        parseEscape() {
            if (this.char in escapes) return this.return(escapes[this.char]);
            else if (this.char === CHAR_u) return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
            else if (this.char === CHAR_U) return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
            else throw this.error(new TomlError("Unknown escape character: " + this.char));
        }
        parseUnicodeReturn(char) {
            try {
                const codePoint = parseInt(char, 16);
                if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
                return this.returnNow(String.fromCodePoint(codePoint));
            } catch (err) {
                throw this.error(TomlError.wrap(err));
            }
        }
        parseSmallUnicode() {
            if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
            else {
                this.consume();
                if (this.state.buf.length >= 4) return this.return();
            }
        }
        parseLargeUnicode() {
            if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
            else {
                this.consume();
                if (this.state.buf.length >= 8) return this.return();
            }
        }
        /* NUMBERS */ parseNumberSign() {
            this.consume();
            return this.next(this.parseMaybeSignedInfOrNan);
        }
        parseMaybeSignedInfOrNan() {
            if (this.char === CHAR_i) return this.next(this.parseInf);
            else if (this.char === CHAR_n) return this.next(this.parseNan);
            else return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
        }
        parseNumberIntegerStart() {
            if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberIntegerExponentOrDecimal);
            } else return this.goto(this.parseNumberInteger);
        }
        parseNumberIntegerExponentOrDecimal() {
            if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else return this.returnNow(Integer(this.state.buf));
        }
        parseNumberInteger() {
            if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseNoUnder() {
            if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) throw this.error(new TomlError("Unexpected character, expected digit"));
            else if (this.atEndOfWord()) throw this.error(new TomlError("Incomplete number"));
            return this.returnNow();
        }
        parseNumberFloat() {
            if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder, this.parseNumberFloat);
            else if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else return this.returnNow(Float(this.state.buf));
        }
        parseNumberExponentSign() {
            if (isDigit(this.char)) return this.goto(this.parseNumberExponent);
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.call(this.parseNoUnder, this.parseNumberExponent);
            } else throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
        }
        parseNumberExponent() {
            if (isDigit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else return this.returnNow(Float(this.state.buf));
        }
        /* NUMBERS or DATETIMES  */ parseNumberOrDateTime() {
            if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberBaseOrDateTime);
            } else return this.goto(this.parseNumberOrDateTimeOnly);
        }
        parseNumberOrDateTimeOnly() {
            // note, if two zeros are in a row then it MUST be a date
            if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder, this.parseNumberInteger);
            else if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length > 4) this.next(this.parseNumberInteger);
            } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
            } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
            } else if (this.char === CHAR_HYPHEN) return this.goto(this.parseDateTime);
            else if (this.char === CHAR_COLON) return this.goto(this.parseOnlyTimeHour);
            else return this.returnNow(Integer(this.state.buf));
        }
        parseDateTimeOnly() {
            if (this.state.buf.length < 4) {
                if (isDigit(this.char)) return this.consume();
                else if (this.char === CHAR_COLON) return this.goto(this.parseOnlyTimeHour);
                else throw this.error(new TomlError("Expected digit while parsing year part of a date"));
            } else {
                if (this.char === CHAR_HYPHEN) return this.goto(this.parseDateTime);
                else throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
            }
        }
        parseNumberBaseOrDateTime() {
            if (this.char === CHAR_b) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerBin);
            } else if (this.char === CHAR_o) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerOct);
            } else if (this.char === CHAR_x) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerHex);
            } else if (this.char === CHAR_PERIOD) return this.goto(this.parseNumberInteger);
            else if (isDigit(this.char)) return this.goto(this.parseDateTimeOnly);
            else return this.returnNow(Integer(this.state.buf));
        }
        parseIntegerHex() {
            if (isHexit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseIntegerOct() {
            if (isOctit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        parseIntegerBin() {
            if (isBit(this.char)) this.consume();
            else if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
            else {
                const result = Integer(this.state.buf);
                /* istanbul ignore if */ if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                else return this.returnNow(result);
            }
        }
        /* DATETIME */ parseDateTime() {
            // we enter here having just consumed the year and about to consume the hyphen
            if (this.state.buf.length < 4) throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
            this.state.result = this.state.buf;
            this.state.buf = "";
            return this.next(this.parseDateMonth);
        }
        parseDateMonth() {
            if (this.char === CHAR_HYPHEN) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseDateDay);
            } else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseDateDay() {
            if (this.char === CHAR_T || this.char === CHAR_SP) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseStartTimeHour);
            } else if (this.atEndOfWord()) return this.return($gbrcb(this.state.result + "-" + this.state.buf));
            else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseStartTimeHour() {
            if (this.atEndOfWord()) return this.returnNow($gbrcb(this.state.result));
            else return this.goto(this.parseTimeHour);
        }
        parseTimeHour() {
            if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                this.state.result += "T" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeMin);
            } else if (isDigit(this.char)) this.consume();
            else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseTimeMin() {
            if (this.state.buf.length < 2 && isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeSec);
            } else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseTimeSec() {
            if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) {
                    this.state.result += ":" + this.state.buf;
                    this.state.buf = "";
                    return this.next(this.parseTimeZoneOrFraction);
                }
            } else throw this.error(new TomlError("Incomplete datetime"));
        }
        parseOnlyTimeHour() {
            /* istanbul ignore else */ if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                this.state.result = this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeMin);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeMin() {
            if (this.state.buf.length < 2 && isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeSec);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeSec() {
            if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) return this.next(this.parseOnlyTimeFractionMaybe);
            } else throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeFractionMaybe() {
            this.state.result += ":" + this.state.buf;
            if (this.char === CHAR_PERIOD) {
                this.state.buf = "";
                this.next(this.parseOnlyTimeFraction);
            } else return this.return($636jz(this.state.result));
        }
        parseOnlyTimeFraction() {
            if (isDigit(this.char)) this.consume();
            else if (this.atEndOfWord()) {
                if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
                return this.returnNow($636jz(this.state.result + "." + this.state.buf));
            } else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseTimeZoneOrFraction() {
            if (this.char === CHAR_PERIOD) {
                this.consume();
                this.next(this.parseDateTimeFraction);
            } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
            } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return($bS2MF(this.state.result + this.state.buf));
            } else if (this.atEndOfWord()) return this.returnNow($9dYMx(this.state.result + this.state.buf));
            else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseDateTimeFraction() {
            if (isDigit(this.char)) this.consume();
            else if (this.state.buf.length === 1) throw this.error(new TomlError("Expected digit in milliseconds"));
            else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
            } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return($bS2MF(this.state.result + this.state.buf));
            } else if (this.atEndOfWord()) return this.returnNow($9dYMx(this.state.result + this.state.buf));
            else throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseTimeZoneHour() {
            if (isDigit(this.char)) {
                this.consume();
                // FIXME: No more regexps
                if (/\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
            } else throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        parseTimeZoneSep() {
            if (this.char === CHAR_COLON) {
                this.consume();
                this.next(this.parseTimeZoneMin);
            } else throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
        }
        parseTimeZoneMin() {
            if (isDigit(this.char)) {
                this.consume();
                if (/\d\d$/.test(this.state.buf)) return this.return($bS2MF(this.state.result + this.state.buf));
            } else throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        /* BOOLEAN */ parseBoolean() {
            /* istanbul ignore else */ if (this.char === CHAR_t) {
                this.consume();
                return this.next(this.parseTrue_r);
            } else if (this.char === CHAR_f) {
                this.consume();
                return this.next(this.parseFalse_a);
            }
        }
        parseTrue_r() {
            if (this.char === CHAR_r) {
                this.consume();
                return this.next(this.parseTrue_u);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_u() {
            if (this.char === CHAR_u) {
                this.consume();
                return this.next(this.parseTrue_e);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_e() {
            if (this.char === CHAR_e) return this.return(true);
            else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_a() {
            if (this.char === CHAR_a) {
                this.consume();
                return this.next(this.parseFalse_l);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_l() {
            if (this.char === CHAR_l) {
                this.consume();
                return this.next(this.parseFalse_s);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_s() {
            if (this.char === CHAR_s) {
                this.consume();
                return this.next(this.parseFalse_e);
            } else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_e() {
            if (this.char === CHAR_e) return this.return(false);
            else throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        /* INLINE LISTS */ parseInlineList() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
            else if (this.char === Parser.END) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CHAR_RSQB) return this.return(this.state.resultArr || InlineList());
            else return this.callNow(this.parseValue, this.recordInlineListValue);
        }
        recordInlineListValue(value) {
            if (this.state.resultArr) {
                const listType = this.state.resultArr[_contentType];
                const valueType = tomlType(value);
                if (listType !== valueType) throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
            } else this.state.resultArr = InlineList(tomlType(value));
            if (isFloat(value) || isInteger(value)) // unbox now that we've verified they're ok
            this.state.resultArr.push(value.valueOf());
            else this.state.resultArr.push(value);
            return this.goto(this.parseInlineListNext);
        }
        parseInlineListNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
            else if (this.char === CHAR_NUM) return this.call(this.parseComment);
            else if (this.char === CHAR_COMMA) return this.next(this.parseInlineList);
            else if (this.char === CHAR_RSQB) return this.goto(this.parseInlineList);
            else throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
        /* INLINE TABLE */ parseInlineTable() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_RCUB) return this.return(this.state.resultTable || InlineTable());
            else {
                if (!this.state.resultTable) this.state.resultTable = InlineTable();
                return this.callNow(this.parseAssign, this.recordInlineTableValue);
            }
        }
        recordInlineTableValue(kv) {
            let target = this.state.resultTable;
            let finalKey = kv.key.pop();
            for (let kw of kv.key){
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                target = target[kw] = target[kw] || Table();
            }
            if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
            if (isInteger(kv.value) || isFloat(kv.value)) target[finalKey] = kv.value.valueOf();
            else target[finalKey] = kv.value;
            return this.goto(this.parseInlineTableNext);
        }
        parseInlineTableNext() {
            if (this.char === CHAR_SP || this.char === CTRL_I) return null;
            else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
            else if (this.char === CHAR_COMMA) return this.next(this.parseInlineTable);
            else if (this.char === CHAR_RCUB) return this.goto(this.parseInlineTable);
            else throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
    }
    return TOMLParser;
}

});
parcelRequire.register("8E52p", function(module, exports) {
"use strict";
const $64b5f7964fcf57fb$var$ParserEND = 0x110000;
class $64b5f7964fcf57fb$var$ParserError extends Error {
    /* istanbul ignore next */ constructor(msg, filename, linenumber){
        super("[ParserError] " + msg, filename, linenumber);
        this.name = "ParserError";
        this.code = "ParserError";
        if (Error.captureStackTrace) Error.captureStackTrace(this, $64b5f7964fcf57fb$var$ParserError);
    }
}
class $64b5f7964fcf57fb$var$State {
    constructor(parser){
        this.parser = parser;
        this.buf = "";
        this.returned = null;
        this.result = null;
        this.resultTable = null;
        this.resultArr = null;
    }
}
class $64b5f7964fcf57fb$var$Parser {
    constructor(){
        this.pos = 0;
        this.col = 0;
        this.line = 0;
        this.obj = {};
        this.ctx = this.obj;
        this.stack = [];
        this._buf = "";
        this.char = null;
        this.ii = 0;
        this.state = new $64b5f7964fcf57fb$var$State(this.parseStart);
    }
    parse(str) {
        /* istanbul ignore next */ if (str.length === 0 || str.length == null) return;
        this._buf = String(str);
        this.ii = -1;
        this.char = -1;
        let getNext;
        while(getNext === false || this.nextChar())getNext = this.runOne();
        this._buf = null;
    }
    nextChar() {
        if (this.char === 0x0A) {
            ++this.line;
            this.col = -1;
        }
        ++this.ii;
        this.char = this._buf.codePointAt(this.ii);
        ++this.pos;
        ++this.col;
        return this.haveBuffer();
    }
    haveBuffer() {
        return this.ii < this._buf.length;
    }
    runOne() {
        return this.state.parser.call(this, this.state.returned);
    }
    finish() {
        this.char = $64b5f7964fcf57fb$var$ParserEND;
        let last;
        do {
            last = this.state.parser;
            this.runOne();
        }while (this.state.parser !== last);
        this.ctx = null;
        this.state = null;
        this._buf = null;
        return this.obj;
    }
    next(fn) {
        /* istanbul ignore next */ if (typeof fn !== "function") throw new $64b5f7964fcf57fb$var$ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
        this.state.parser = fn;
    }
    goto(fn) {
        this.next(fn);
        return this.runOne();
    }
    call(fn, returnWith) {
        if (returnWith) this.next(returnWith);
        this.stack.push(this.state);
        this.state = new $64b5f7964fcf57fb$var$State(fn);
    }
    callNow(fn, returnWith) {
        this.call(fn, returnWith);
        return this.runOne();
    }
    return(value) {
        /* istanbul ignore next */ if (this.stack.length === 0) throw this.error(new $64b5f7964fcf57fb$var$ParserError("Stack underflow"));
        if (value === undefined) value = this.state.buf;
        